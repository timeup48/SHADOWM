#!/bin/bash

# ============================================================================
# Reconnaissance Module for CVEHACK
# ============================================================================

# Source required libraries
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../lib/colors.sh"
source "$SCRIPT_DIR/../lib/logger.sh"

# ============================================================================
# Reconnaissance Menu
# ============================================================================

show_recon_menu() {
    local target="$1"
    
    while true; do
        clear_screen
        section_header "🔍 Reconnaissance & Information Gathering"
        
        echo -e "${GREEN}Target: ${YELLOW}$target${NC}"
        echo ""
        echo -e "${YELLOW}1.${NC} 🌐 Domain & DNS Information"
        echo -e "${YELLOW}2.${NC} 🔌 Port Scanning (Quick)"
        echo -e "${YELLOW}3.${NC} 🔍 Port Scanning (Comprehensive)"
        echo -e "${YELLOW}4.${NC} 🏢 Service Detection & OS Fingerprinting"
        echo -e "${YELLOW}5.${NC} 📡 Subdomain Enumeration"
        echo -e "${YELLOW}6.${NC} 🕷️ Web Technology Detection"
        echo -e "${YELLOW}7.${NC} 📧 Email & Contact Information Gathering"
        echo -e "${YELLOW}8.${NC} 🔗 SSL/TLS Certificate Analysis"
        echo -e "${YELLOW}9.${NC} 📊 Network Range Discovery"
        echo -e "${YELLOW}10.${NC} ⚡ Full Reconnaissance Suite"
        echo ""
        echo -e "${YELLOW}0.${NC} 🔙 Back to Main Menu"
        echo ""
        echo -e "${BLUE}Select reconnaissance option: ${NC}"
        read -r recon_choice
        
        case $recon_choice in
            1) domain_dns_recon "$target" ;;
            2) quick_port_scan "$target" ;;
            3) comprehensive_port_scan "$target" ;;
            4) service_detection "$target" ;;
            5) subdomain_enumeration "$target" ;;
            6) web_technology_detection "$target" ;;
            7) email_contact_gathering "$target" ;;
            8) ssl_certificate_analysis "$target" ;;
            9) network_range_discovery "$target" ;;
            10) full_recon_scan "$target" ;;
            0) return ;;
            *) print_error "Invalid option. Please try again." ;;
        esac
        
        echo ""
        print_info "Press Enter to continue..."
        read -r
    done
}

# ============================================================================
# Domain & DNS Information Gathering
# ============================================================================

domain_dns_recon() {
    local target="$1"
    
    subsection_header "Domain & DNS Information Gathering"
    log_scan_start "DNS Reconnaissance" "$target"
    
    print_info "Gathering DNS information for $target..."
    
    # Basic DNS lookup
    print_info "Performing basic DNS lookup..."
    local dns_output=""
    
    if command -v dig &> /dev/null; then
        dns_output=$(dig +short "$target" 2>/dev/null)
        if [[ -n "$dns_output" ]]; then
            print_success "DNS A Records:"
            echo "$dns_output" | while read -r ip; do
                print_info "  $ip"
            done
        fi
        
        # MX Records
        print_info "Checking MX records..."
        local mx_records=$(dig +short MX "$target" 2>/dev/null)
        if [[ -n "$mx_records" ]]; then
            print_success "MX Records found:"
            echo "$mx_records" | while read -r mx; do
                print_info "  $mx"
            done
        fi
        
        # TXT Records
        print_info "Checking TXT records..."
        local txt_records=$(dig +short TXT "$target" 2>/dev/null)
        if [[ -n "$txt_records" ]]; then
            print_success "TXT Records found:"
            echo "$txt_records" | while read -r txt; do
                print_info "  $txt"
            done
        fi
        
        # NS Records
        print_info "Checking NS records..."
        local ns_records=$(dig +short NS "$target" 2>/dev/null)
        if [[ -n "$ns_records" ]]; then
            print_success "NS Records found:"
            echo "$ns_records" | while read -r ns; do
                print_info "  $ns"
            done
        fi
        
    else
        print_warning "dig not available, using nslookup..."
        dns_output=$(nslookup "$target" 2>/dev/null | grep "Address:" | tail -n +2 | awk '{print $2}')
    fi
    
    # Reverse DNS lookup
    if [[ -n "$dns_output" ]]; then
        print_info "Performing reverse DNS lookup..."
        echo "$dns_output" | while read -r ip; do
            if [[ "$ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                local reverse=$(dig +short -x "$ip" 2>/dev/null || nslookup "$ip" 2>/dev/null | grep "name =" | awk '{print $4}')
                if [[ -n "$reverse" ]]; then
                    print_success "Reverse DNS for $ip: $reverse"
                fi
            fi
        done
    fi
    
    # WHOIS information
    if command -v whois &> /dev/null; then
        print_info "Gathering WHOIS information..."
        local whois_output=$(whois "$target" 2>/dev/null | head -50)
        if [[ -n "$whois_output" ]]; then
            print_success "WHOIS information gathered"
            echo "$whois_output" | grep -E "(Registrar|Creation Date|Expiry Date|Name Server)" | head -10
        fi
    fi
    
    # Save results
    local dns_data="DNS Reconnaissance Results for $target
Generated: $(date)

A Records:
$dns_output

MX Records:
$mx_records

TXT Records:
$txt_records

NS Records:
$ns_records
"
    
    save_scan_data "dns_recon" "$target" "$dns_data"
    log_scan_result "DNS Reconnaissance" "$target" "$dns_data"
    
    print_success "DNS reconnaissance completed"
}

# ============================================================================
# Port Scanning Functions
# ============================================================================

quick_port_scan() {
    local target="$1"
    
    subsection_header "Quick Port Scan"
    log_scan_start "Quick Port Scan" "$target"
    
    print_info "Performing quick port scan on $target..."
    print_info "Scanning top 1000 ports..."
    
    if ! command -v nmap &> /dev/null; then
        print_error "nmap not found. Please install nmap first."
        return 1
    fi
    
    # Quick TCP scan
    local nmap_output=$(nmap -sS -F --open "$target" 2>/dev/null)
    
    if [[ -n "$nmap_output" ]]; then
        print_success "Port scan completed"
        
        # Parse and display results
        echo "$nmap_output" | grep -E "^[0-9]+/(tcp|udp)" | while read -r line; do
            local port=$(echo "$line" | awk '{print $1}')
            local state=$(echo "$line" | awk '{print $2}')
            local service=$(echo "$line" | awk '{print $3}')
            
            case "$state" in
                "open")
                    print_success "Port $port: $(port_status_color "open") - $service"
                    ;;
                "closed")
                    print_info "Port $port: $(port_status_color "closed") - $service"
                    ;;
                "filtered")
                    print_warning "Port $port: $(port_status_color "filtered") - $service"
                    ;;
            esac
        done
        
        # Count open ports
        local open_count=$(echo "$nmap_output" | grep -c "open")
        print_info "Total open ports found: $open_count"
        
    else
        print_error "No scan results obtained"
        return 1
    fi
    
    save_scan_data "quick_port_scan" "$target" "$nmap_output"
    log_scan_result "Quick Port Scan" "$target" "$nmap_output"
    
    print_success "Quick port scan completed"
}

comprehensive_port_scan() {
    local target="$1"
    
    subsection_header "Comprehensive Port Scan"
    log_scan_start "Comprehensive Port Scan" "$target"
    
    print_info "Performing comprehensive port scan on $target..."
    print_warning "This may take several minutes..."
    
    if ! command -v nmap &> /dev/null; then
        print_error "nmap not found. Please install nmap first."
        return 1
    fi
    
    # Comprehensive TCP scan
    print_info "Scanning all TCP ports..."
    local tcp_output=$(nmap -sS -p- --open -T4 "$target" 2>/dev/null)
    
    # UDP scan on common ports
    print_info "Scanning common UDP ports..."
    local udp_output=$(nmap -sU --top-ports 100 --open "$target" 2>/dev/null)
    
    # Combine results
    local full_output="TCP Scan Results:
$tcp_output

UDP Scan Results:
$udp_output"
    
    if [[ -n "$tcp_output" ]]; then
        print_success "TCP scan completed"
        echo "$tcp_output" | grep -E "^[0-9]+/tcp" | while read -r line; do
            local port=$(echo "$line" | awk '{print $1}')
            local state=$(echo "$line" | awk '{print $2}')
            local service=$(echo "$line" | awk '{print $3}')
            print_success "TCP $port: $(port_status_color "$state") - $service"
        done
    fi
    
    if [[ -n "$udp_output" ]]; then
        print_success "UDP scan completed"
        echo "$udp_output" | grep -E "^[0-9]+/udp" | while read -r line; do
            local port=$(echo "$line" | awk '{print $1}')
            local state=$(echo "$line" | awk '{print $2}')
            local service=$(echo "$line" | awk '{print $3}')
            print_success "UDP $port: $(port_status_color "$state") - $service"
        done
    fi
    
    save_scan_data "comprehensive_port_scan" "$target" "$full_output"
    log_scan_result "Comprehensive Port Scan" "$target" "$full_output"
    
    print_success "Comprehensive port scan completed"
}

# ============================================================================
# Service Detection & OS Fingerprinting
# ============================================================================

service_detection() {
    local target="$1"
    
    subsection_header "Service Detection & OS Fingerprinting"
    log_scan_start "Service Detection" "$target"
    
    print_info "Performing service detection on $target..."
    
    if ! command -v nmap &> /dev/null; then
        print_error "nmap not found. Please install nmap first."
        return 1
    fi
    
    # Service version detection
    print_info "Detecting service versions..."
    local service_output=$(nmap -sV -sC --open "$target" 2>/dev/null)
    
    # OS fingerprinting
    print_info "Attempting OS fingerprinting..."
    local os_output=$(nmap -O "$target" 2>/dev/null)
    
    # Parse service results
    if [[ -n "$service_output" ]]; then
        print_success "Service detection completed"
        
        echo "$service_output" | grep -E "^[0-9]+/(tcp|udp)" | while read -r line; do
            local port=$(echo "$line" | awk '{print $1}')
            local state=$(echo "$line" | awk '{print $2}')
            local service=$(echo "$line" | awk '{print $3}')
            local version=$(echo "$line" | cut -d' ' -f4-)
            
            if [[ "$state" == "open" ]]; then
                print_success "Port $port: $service"
                if [[ -n "$version" && "$version" != "$service" ]]; then
                    print_info "  Version: $version"
                fi
            fi
        done
    fi
    
    # Parse OS results
    if [[ -n "$os_output" ]]; then
        local os_guess=$(echo "$os_output" | grep "OS details:" | cut -d: -f2- | xargs)
        if [[ -n "$os_guess" ]]; then
            print_success "OS Detection: $os_guess"
        fi
        
        local os_accuracy=$(echo "$os_output" | grep "Aggressive OS guesses:" | head -1 | cut -d: -f2- | xargs)
        if [[ -n "$os_accuracy" ]]; then
            print_info "OS Guess: $os_accuracy"
        fi
    fi
    
    # Combine results
    local full_output="Service Detection Results:
$service_output

OS Fingerprinting Results:
$os_output"
    
    save_scan_data "service_detection" "$target" "$full_output"
    log_scan_result "Service Detection" "$target" "$full_output"
    
    print_success "Service detection completed"
}

# ============================================================================
# Subdomain Enumeration
# ============================================================================

subdomain_enumeration() {
    local target="$1"
    
    subsection_header "Subdomain Enumeration"
    log_scan_start "Subdomain Enumeration" "$target"
    
    print_info "Enumerating subdomains for $target..."
    
    local subdomains=""
    
    # Using subfinder if available
    if command -v subfinder &> /dev/null; then
        print_info "Using subfinder for passive enumeration..."
        local subfinder_output=$(subfinder -d "$target" -silent 2>/dev/null)
        if [[ -n "$subfinder_output" ]]; then
            subdomains="$subfinder_output"
            print_success "Subfinder found $(echo "$subfinder_output" | wc -l) subdomains"
        fi
    fi
    
    # Using amass if available
    if command -v amass &> /dev/null; then
        print_info "Using amass for comprehensive enumeration..."
        local amass_output=$(timeout 300 amass enum -passive -d "$target" 2>/dev/null)
        if [[ -n "$amass_output" ]]; then
            subdomains="$subdomains
$amass_output"
            print_success "Amass found additional subdomains"
        fi
    fi
    
    # DNS brute force with common subdomains
    if [[ -z "$subdomains" ]]; then
        print_info "Performing DNS brute force with common subdomains..."
        local common_subs=("www" "mail" "ftp" "admin" "test" "dev" "staging" "api" "blog" "shop" "forum" "support" "help" "docs" "cdn" "static" "img" "images" "js" "css" "assets")
        
        for sub in "${common_subs[@]}"; do
            local full_domain="$sub.$target"
            if dig +short "$full_domain" &>/dev/null; then
                local ip=$(dig +short "$full_domain" 2>/dev/null)
                if [[ -n "$ip" ]]; then
                    subdomains="$subdomains
$full_domain"
                    print_success "Found: $full_domain -> $ip"
                fi
            fi
        done
    fi
    
    # Remove duplicates and sort
    if [[ -n "$subdomains" ]]; then
        subdomains=$(echo "$subdomains" | sort -u | grep -v "^$")
        local subdomain_count=$(echo "$subdomains" | wc -l)
        
        print_success "Total unique subdomains found: $subdomain_count"
        
        # Display results
        echo "$subdomains" | while read -r subdomain; do
            if [[ -n "$subdomain" ]]; then
                local ip=$(dig +short "$subdomain" 2>/dev/null | head -1)
                print_info "$subdomain -> $ip"
            fi
        done
        
        # Test subdomain accessibility
        print_info "Testing subdomain accessibility..."
        echo "$subdomains" | while read -r subdomain; do
            if [[ -n "$subdomain" ]]; then
                if curl -s --connect-timeout 5 "http://$subdomain" >/dev/null 2>&1; then
                    print_success "$subdomain is accessible (HTTP)"
                elif curl -s --connect-timeout 5 "https://$subdomain" >/dev/null 2>&1; then
                    print_success "$subdomain is accessible (HTTPS)"
                fi
            fi
        done
        
    else
        print_warning "No subdomains found"
    fi
    
    save_scan_data "subdomain_enum" "$target" "$subdomains"
    log_scan_result "Subdomain Enumeration" "$target" "$subdomains"
    
    print_success "Subdomain enumeration completed"
}

# ============================================================================
# Web Technology Detection
# ============================================================================

web_technology_detection() {
    local target="$1"
    
    subsection_header "Web Technology Detection"
    log_scan_start "Web Technology Detection" "$target"
    
    print_info "Detecting web technologies for $target..."
    
    # Ensure target has protocol
    if [[ ! "$target" =~ ^https?:// ]]; then
        # Try HTTPS first, then HTTP
        if curl -s --connect-timeout 5 "https://$target" >/dev/null 2>&1; then
            target="https://$target"
        else
            target="http://$target"
        fi
    fi
    
    local tech_results=""
    
    # Using whatweb if available
    if command -v whatweb &> /dev/null; then
        print_info "Using whatweb for technology detection..."
        local whatweb_output=$(whatweb --color=never "$target" 2>/dev/null)
        if [[ -n "$whatweb_output" ]]; then
            tech_results="WhatWeb Results:
$whatweb_output"
            print_success "WhatWeb scan completed"
            
            # Parse interesting findings
            if echo "$whatweb_output" | grep -q "WordPress"; then
                print_warning "WordPress detected"
            fi
            if echo "$whatweb_output" | grep -q "Apache"; then
                print_info "Apache web server detected"
            fi
            if echo "$whatweb_output" | grep -q "nginx"; then
                print_info "Nginx web server detected"
            fi
        fi
    fi
    
    # Manual HTTP header analysis
    print_info "Analyzing HTTP headers..."
    local headers=$(curl -s -I "$target" 2>/dev/null)
    
    if [[ -n "$headers" ]]; then
        tech_results="$tech_results

HTTP Headers Analysis:
$headers"
        
        # Parse headers for technology indicators
        if echo "$headers" | grep -qi "server:"; then
            local server=$(echo "$headers" | grep -i "server:" | cut -d: -f2- | xargs)
            print_success "Web Server: $server"
        fi
        
        if echo "$headers" | grep -qi "x-powered-by:"; then
            local powered_by=$(echo "$headers" | grep -i "x-powered-by:" | cut -d: -f2- | xargs)
            print_success "Powered By: $powered_by"
        fi
        
        if echo "$headers" | grep -qi "x-generator:"; then
            local generator=$(echo "$headers" | grep -i "x-generator:" | cut -d: -f2- | xargs)
            print_success "Generator: $generator"
        fi
        
        # Security headers check
        print_info "Checking security headers..."
        local security_headers=("X-Frame-Options" "X-XSS-Protection" "X-Content-Type-Options" "Strict-Transport-Security" "Content-Security-Policy")
        
        for header in "${security_headers[@]}"; do
            if echo "$headers" | grep -qi "$header:"; then
                print_success "Security header present: $header"
            else
                print_warning "Missing security header: $header"
            fi
        done
    fi
    
    # Check for common web application files
    print_info "Checking for common web application indicators..."
    local common_files=("robots.txt" "sitemap.xml" "wp-admin" "admin" "phpmyadmin" ".git" ".svn")
    
    for file in "${common_files[@]}"; do
        local test_url="$target/$file"
        local response=$(curl -s -o /dev/null -w "%{http_code}" "$test_url" 2>/dev/null)
        
        if [[ "$response" == "200" ]]; then
            print_warning "Found: $file (HTTP $response)"
        elif [[ "$response" == "403" ]]; then
            print_info "Found but forbidden: $file (HTTP $response)"
        fi
    done
    
    save_scan_data "web_tech_detection" "$target" "$tech_results"
    log_scan_result "Web Technology Detection" "$target" "$tech_results"
    
    print_success "Web technology detection completed"
}

# ============================================================================
# Email & Contact Information Gathering
# ============================================================================
email_contact_gathering() {
    local target="$1"

    subsection_header "Email & Contact Information Gathering"
    log_scan_start "Email Gathering" "$target"

    print_info "Gathering email and contact information for $target..."
    local contact_info=""

    # Using theHarvester if available
    if command -v theHarvester &> /dev/null; then
        print_info "Using theHarvester for email enumeration..."
        local harvester_output
        harvester_output=$(theHarvester -d "$target" -l 100 -b google 2>/dev/null)
        if [[ -n "$harvester_output" ]]; then
            contact_info="$contact_info

TheHarvester Results:
$harvester_output"
        fi
    fi

    # Manual web scraping for contact information
    print_info "Scraping website for contact information..."
    if [[ ! "$target" =~ ^https?:// ]]; then
        target="https://$target"
    fi

    local webpage
    webpage=$(curl -sL "$target" 2>/dev/null)
    if [[ -n "$webpage" ]]; then
        # Extract emails
        local web_emails
        web_emails=$(echo "$webpage" | grep -Eio "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}" | sort -u)
        if [[ -n "$web_emails" ]]; then
            print_success "Emails found directly on website:"
            echo "$web_emails" | while read -r email; do
                print_info "  $email"
            done
            contact_info="$contact_info

Website Email Extraction:
$web_emails"
        else
            print_warning "No emails found directly on the site."
        fi

        # Extract phone numbers
        local phone_numbers
        phone_numbers=$(echo "$webpage" | grep -oE "(\+?[0-9]{1,3}[-.\s]?)?(\([0-9]{3}\)|[0-9]{3})[-.\s]?[0-9]{3}[-.\s]?[0-9]{4}" | sort -u)
        if [[ -n "$phone_numbers" ]]; then
            print_success "Phone numbers found:"
            echo "$phone_numbers" | while read -r phone; do
                print_info "  $phone"
            done
            contact_info="$contact_info

Phone Numbers:
$phone_numbers"
        fi

        # Check social media links
        print_info "Checking for social media links..."
        local social_platforms=("facebook.com" "twitter.com" "linkedin.com" "instagram.com" "youtube.com" "github.com")
        for platform in "${social_platforms[@]}"; do
            if echo "$webpage" | grep -q "$platform"; then
                local social_links
                social_links=$(echo "$webpage" | grep -oE "https?://[^\"']*$platform[^\"']*" | sort -u)
                if [[ -n "$social_links" ]]; then
                    print_success "Found $platform links:"
                    echo "$social_links" | while read -r link; do
                        print_info "  $link"
                    done
                    contact_info="$contact_info

$platform Links:
$social_links"
                fi
            fi
        done
    else
        print_error "Unable to fetch target website."
    fi

    save_scan_data "email_contact_gathering" "$target" "$contact_info"
    log_scan_result "Email & Contact Gathering" "$target" "$contact_info"

    print_success "Email and contact information gathering completed"
}

# ============================================================================
# SSL/TLS Certificate Analysis
# ============================================================================
ssl_certificate_analysis() {
    local target="$1"

    subsection_header "SSL/TLS Certificate Analysis"
    log_scan_start "SSL Certificate Analysis" "$target"

    print_info "Analyzing SSL/TLS certificate for $target..."

    # Remove protocol if present
    target=$(echo "$target" | sed 's|^https\?://||')

    local ssl_results=""

    # Using sslscan if available
    if command -v sslscan &> /dev/null; then
        print_info "Using sslscan for comprehensive SSL analysis..."
        local sslscan_output
        sslscan_output=$(sslscan "$target" 2>/dev/null)
        if [[ -n "$sslscan_output" ]]; then
            ssl_results="SSLScan Results:
$sslscan_output"

            # Parse key findings
            if echo "$sslscan_output" | grep -q "SSLv2"; then
                print_error "SSLv2 is enabled (CRITICAL vulnerability)"
            fi
            if echo "$sslscan_output" | grep -q "SSLv3"; then
                print_warning "SSLv3 is enabled (vulnerable to POODLE)"
            fi
            if echo "$sslscan_output" | grep -q "TLSv1.3"; then
                print_success "TLS 1.3 is supported"
            fi
        fi
    fi

    # Manual certificate inspection using openssl
    print_info "Inspecting certificate details..."
    local cert_info
    cert_info=$(echo | openssl s_client -connect "$target:443" -servername "$target" 2>/dev/null | openssl x509 -noout -text 2>/dev/null)

    if [[ -n "$cert_info" ]]; then
        ssl_results="$ssl_results

Certificate Details:
$cert_info"

        local issuer subject not_after
        issuer=$(echo "$cert_info" | grep "Issuer:" | cut -d: -f2- | xargs)
        subject=$(echo "$cert_info" | grep "Subject:" | cut -d: -f2- | xargs)
        not_after=$(echo "$cert_info" | grep "Not After" | cut -d: -f2- | xargs)

        if [[ -n "$issuer" ]]; then
            print_success "Certificate Issuer: $issuer"
        fi
        if [[ -n "$subject" ]]; then
            print_success "Certificate Subject: $subject"
        fi
        if [[ -n "$not_after" ]]; then
            print_info "Certificate Expires: $not_after"
            local expiry_date current_date days_until_expiry
            expiry_date=$(date -d "$not_after" +%s 2>/dev/null)
            current_date=$(date +%s)
            days_until_expiry=$(( (expiry_date - current_date) / 86400 ))

            if [[ $days_until_expiry -lt 30 ]]; then
                print_warning "Certificate expires in $days_until_expiry days"
            fi
        fi

        local san
        san=$(echo "$cert_info" | grep -A 1 "Subject Alternative Name" | tail -1)
        if [[ -n "$san" ]]; then
            print_success "Subject Alternative Names: $san"
        fi
    fi

    # Test SSL/TLS configuration
    print_info "Testing SSL/TLS configuration..."
    local tls_versions=("ssl2" "ssl3" "tls1" "tls1_1" "tls1_2" "tls1_3")
    for version in "${tls_versions[@]}"; do
        if echo | openssl s_client -connect "$target:443" -"$version" 2>/dev/null | grep -q "Verify return code: 0"; then
            case "$version" in
                "ssl2"|"ssl3")
                    print_error "$version is supported (VULNERABLE)"
                    ;;
                "tls1"|"tls1_1")
                    print_warning "$version is supported (DEPRECATED)"
                    ;;
                "tls1_2"|"tls1_3")
                    print_success "$version is supported"
                    ;;
            esac
        fi
    done

    save_scan_data "ssl_analysis" "$target" "$ssl_results"
    log_scan_result "SSL Certificate Analysis" "$target" "$ssl_results"

    print_success "SSL/TLS certificate analysis completed"
}

# ============================================================================
# Network Range Discovery
# ============================================================================
network_range_discovery() {
    local target="$1"

    subsection_header "Network Range Discovery"
    log_scan_start "Network Range Discovery" "$target"

    print_info "Discovering network range for $target..."

    local target_ip
    target_ip=$(dig +short "$target" 2>/dev/null | head -1)
    if [[ -z "$target_ip" ]] || [[ ! "$target_ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        if [[ "$target" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            target_ip="$target"
        else
            print_error "Could not resolve target to IP address"
            return 1
        fi
    fi

    print_success "Target IP: $target_ip"

    local network_range
    network_range=$(echo "$target_ip" | cut -d. -f1-3).0/24
    print_info "Scanning network range: $network_range"

    local alive_hosts=""
    if command -v nmap &> /dev/null; then
        alive_hosts=$(nmap -sn "$network_range" 2>/dev/null | grep "Nmap scan report" | awk '{print $5}')
        if [[ -n "$alive_hosts" ]]; then
            print_success "Live hosts discovered:"
            echo "$alive_hosts" | while read -r host; do
                print_info "  $host"
            done
        else
            print_warning "No live hosts found in network range"
        fi
    else
        print_warning "nmap not available for network discovery"
    fi

    local network_data="Network Range Discovery Results for $target
Generated: $(date)

Target IP: $target_ip
Network Range: $network_range

Live Hosts:
$alive_hosts"

    save_scan_data "network_discovery" "$target" "$network_data"
    log_scan_result "Network Range Discovery" "$target" "$network_data"

    print_success "Network range discovery completed"
}

# ============================================================================
# Full Reconnaissance Scan
# ============================================================================
full_recon_scan() {
    local target="$1"

    section_header "Full Reconnaissance Scan"
    log_scan_start "Full Reconnaissance" "$target"

    print_info "Starting comprehensive reconnaissance on $target..."
    print_warning "This may take considerable time..."

    domain_dns_recon "$target"
    echo ""

    comprehensive_port_scan "$target"
    echo ""

    service_detection "$target"
    echo ""

    subdomain_enumeration "$target"
    echo ""

    web_technology_detection "$target"
    echo ""

    ssl_certificate_analysis "$target"
    echo ""

    email_contact_gathering "$target"
    echo ""

    network_range_discovery "$target"

    print_success "Full reconnaissance scan completed"
    log_scan_result "Full Reconnaissance" "$target" "Comprehensive reconnaissance completed"
}
